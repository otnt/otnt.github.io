<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pufan Jiang&#39;s Blog</title>
    <description>Pufan Jiang&#39;s personal blog, including lots of tech blogs, photo shooting etc.</description>
    <link>http://huangxuan.me/</link>
    <atom:link href="http://huangxuan.me/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 03 Feb 2017 21:51:10 +0800</pubDate>
    <lastBuildDate>Fri, 03 Feb 2017 21:51:10 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>DP分析之最长回文子串</title>
        <description>&lt;p&gt;最长回文子串(Longest Palindrome Substring)&lt;/p&gt;

&lt;p&gt;Leetcode描述&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/&quot;&gt;在此&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;DP四步骤：&lt;/p&gt;

&lt;p&gt;1.寻找最优子结构&lt;/p&gt;

&lt;p&gt;首先直接想到的是，如果知道i到j范围内的最优解，能否得知i到j+1的最优解。然而发现，可能最优解是i+1到j。联想到回文是一个头尾都要考虑的结构，所以修改子结构为，已知i到j-1内的最优解，以及i+1到j内的最优解，能否得到i到j内的最优解。&lt;/p&gt;

&lt;p&gt;思考后发现是可以的。如果i和j相同，那么最优解就是i+1到j-1的最优解在加上i和j。如果不同，则比较i+1到j，和i到j-1，看哪个更长。&lt;/p&gt;

&lt;p&gt;2.写出递推公式&lt;/p&gt;

&lt;p&gt;f(i, j)表示i到j内的最优解（包括i和j）&lt;/p&gt;

&lt;p&gt;f(i, j) = 1 //if i == j&lt;br /&gt;
          2 + f(i+1, j-1) //if word[i] = word[j]&lt;br /&gt;
          max(f(i+1, j), f(i, j-1)) //if word[i] != word[j]&lt;/p&gt;

&lt;p&gt;3.算法实现&lt;/p&gt;

&lt;p&gt;参考&lt;a href=&quot;https://github.com/otnt/CodeChallenge/blob/master/Algorithm/DynamicProgramming/LongestPalindromeSubsequence.java&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.反推最优结果&lt;/p&gt;

&lt;p&gt;这个非常直观，在维护最优解的长度时，同时维护具体内容即可。&lt;/p&gt;

&lt;p&gt;s(i, j) = word[i] //if i == j&lt;br /&gt;
          word[i] + s(i+1, j-1) + word[j] //if word[i] = word[j]&lt;br /&gt;
          max(s(i+1, j), s(i, j-1)) //if word[i] != word[j]&lt;/p&gt;

&lt;p&gt;5.优化&lt;/p&gt;

&lt;p&gt;空间复杂度可优化到O(N)，当前是O(N^2)&lt;/p&gt;

</description>
        <pubDate>Sat, 21 May 2016 12:25:00 +0800</pubDate>
        <link>http://huangxuan.me/2016/05/21/dp-analysis-longest-palindrome-substring/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/05/21/dp-analysis-longest-palindrome-substring/</guid>
        
        <category>algorithm</category>
        
        <category>interview</category>
        
        
      </item>
    
      <item>
        <title>动态规划题目的一般化</title>
        <description>&lt;p&gt;最近在实习，做题的时间非常有限。翻了下算法导论中动态规划一章，觉得讲的着实好。动态规划其实非常有迹可循，而面试算法考法更是有限。在此分享一下我读了算法导论这一章后对动规解题思路的理解（其中很多内容和我之前&lt;a href=&quot;http://otnt.github.io/2016/04/29/dynamic-programming/&quot;&gt;一篇博文&lt;/a&gt;中的思路不谋而合）。&lt;/p&gt;

&lt;h3 id=&quot;dp&quot;&gt;1. DP要点&lt;/h3&gt;

&lt;p&gt;1.1 DP一般用于优化问题（optimization problem）。这类问题有很多解，DP能快速找到&lt;em&gt;一个最优解&lt;/em&gt;（可能存在多个最优解）。 &lt;br /&gt;
1.2 DP适用于子问题有&lt;em&gt;Overlap&lt;/em&gt;的情况，即子问题之间共享相同的子子问题，或者说，上层解会&lt;em&gt;反复&lt;/em&gt;依赖已经计算过的下层解。而Divide-and-Conquer适用于子问题独立的情况，递归地去解决子问题。&lt;br /&gt;
1.3 存在&lt;em&gt;独立最优子结构&lt;/em&gt;（independent optimal substructure）。即最优化结构要能够由最优子结构独立推导出，而不受其他最优化结构影响。&lt;/p&gt;

&lt;h3 id=&quot;dp-1&quot;&gt;2.DP四步骤&lt;/h3&gt;

&lt;p&gt;3.1 找到最优子结构，即如何由optimal substructure推导出optimal structure.&lt;br /&gt;
3.2 寻找第一步推导的公式，一般用递归的思想去思考&amp;amp;定义。&lt;br /&gt;
3.3 设计算法实现。一般用bottom-up的方式去实现。&lt;br /&gt;
3.4 反推具体的最优解，一般通过同时维护另一个存储空间来实现。&lt;/p&gt;

&lt;h3 id=&quot;dp-case-study&quot;&gt;3. DP Case Study&lt;/h3&gt;

&lt;p&gt;这里分享一些我做DP题目的四步骤。(不断更新)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;最长回文子串&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 21 May 2016 12:22:00 +0800</pubDate>
        <link>http://huangxuan.me/2016/05/21/dynamic-programming-intro-to-algo/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/05/21/dynamic-programming-intro-to-algo/</guid>
        
        <category>algorithm</category>
        
        <category>interview</category>
        
        
      </item>
    
      <item>
        <title>皮克斯唯美爱情微电影《Lava》</title>
        <description>&lt;p&gt;过去的一周，和我生命中的奇迹—饼妹—一起在甘肃南部游玩。期间看了这个微电影，非常喜欢电影中尤克里里欢快的配乐，可爱的卡通形象，和优美的歌词。在此将个人听译的歌词分享给大家。&lt;/p&gt;

&lt;p&gt;视频链接:&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MzAxNjEyMA==&amp;amp;mid=402981239&amp;amp;idx=2&amp;amp;sn=63dd7d2a1b52219f2b5b4166fbfd72cb&amp;amp;scene=1&amp;amp;srcid=0510bSxPN9RUDmhuacJAqxaP&amp;amp;key=b28b03434249256b733cdf85ce1d5d08397eabfd8bb1b7ff8c6adbe08c69e67f152ebf50229b1f73fa6d5326ac9aaeab&amp;amp;ascene=0&amp;amp;uin=MjE4NjE2NDIyNQ%3D%3D&amp;amp;devicetype=iMac+MacBookPro11%2C1+OSX+OSX+10.11.3+build(15D21)&amp;amp;version=11020201&amp;amp;pass_ticket=G6VwcFos76BfdpHPhXOePo%2BKHZJEaGQZbo6txWvPGfvM5msze%2Bsd4DJm2SgsCGFY&quot;&gt;点击此处&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;歌词：&lt;/p&gt;

&lt;p&gt;A long long time ago, there was a volcano&lt;/p&gt;

&lt;p&gt;Living all alone in the middle of the sea&lt;/p&gt;

&lt;p&gt;He sat high above his span, watching all the couples play&lt;/p&gt;

&lt;p&gt;And wishing that, he had some one too&lt;/p&gt;

&lt;p&gt;And from his lava came this song of hope that he sang out love everyday for years and years&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;[Volcano:]&lt;/p&gt;

&lt;p&gt;I have a dream.&lt;/p&gt;

&lt;p&gt;I hope it will come true.&lt;/p&gt;

&lt;p&gt;You are here with me, and I’m here with you.&lt;/p&gt;

&lt;p&gt;I wish that the earth see the sky up above, will send me someone to lava&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Years of singing all alone, turn his lava into stone&lt;/p&gt;

&lt;p&gt;** until he was on the green extinction?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;But little did he know that living in the sea below&lt;/p&gt;

&lt;p&gt;One other volcano was listening to his song&lt;/p&gt;

&lt;p&gt;Everyday she heard this too&lt;/p&gt;

&lt;p&gt;Her lava grew and grew&lt;/p&gt;

&lt;p&gt;Because she believed his song was made for her&lt;/p&gt;

&lt;p&gt;Now she was so ready to meet him above the sea&lt;/p&gt;

&lt;p&gt;As he sang his song of hope for the last time&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;[Volcano:]&lt;/p&gt;

&lt;p&gt;I have a dream.&lt;/p&gt;

&lt;p&gt;I hope it will come true.&lt;/p&gt;

&lt;p&gt;You are here with me, and I’m here with you.&lt;/p&gt;

&lt;p&gt;I wish that the earth see the sky up above, will send me someone to lava&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Rising from the sea below stood the lovely volcano&lt;/p&gt;

&lt;p&gt;Looking all around but she could not see him&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;He tried to sing to let her know that she was not there alone&lt;/p&gt;

&lt;p&gt;** but with no lava has some one so gone&lt;/p&gt;

&lt;p&gt;He felt the sea with his tears&lt;/p&gt;

&lt;p&gt;And watched his dream disappear&lt;/p&gt;

&lt;p&gt;Yet she remembered what his song meant to her&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;[Volcano:]&lt;/p&gt;

&lt;p&gt;I have a dream.&lt;/p&gt;

&lt;p&gt;I hope it will come true.&lt;/p&gt;

&lt;p&gt;You are here with me, and I’m here with you.&lt;/p&gt;

&lt;p&gt;I wish that the earth see the sky up above, will send me someone to lava&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Oh they were so happy&lt;/p&gt;

&lt;p&gt;To finally meet above the sea&lt;/p&gt;

&lt;p&gt;All together now their lava grew and grew&lt;/p&gt;

&lt;p&gt;No longer are they all alone&lt;/p&gt;

&lt;p&gt;** with the loha? as their new home?&lt;/p&gt;

&lt;p&gt;And when we visited down, this is what  they sing&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;[Volcanos together:]&lt;/p&gt;

&lt;p&gt;I have a dream.&lt;/p&gt;

&lt;p&gt;I hope it will come true.&lt;/p&gt;

&lt;p&gt;Now you grow old with me, and I’ll grow old with you.&lt;/p&gt;

&lt;p&gt;We thank the earth till the sky we’ve been to&lt;/p&gt;

&lt;p&gt;I lava you&lt;/p&gt;

&lt;p&gt;I lava you&lt;/p&gt;

&lt;p&gt;I lava you&lt;/p&gt;

&lt;p&gt;[End]&lt;/p&gt;
</description>
        <pubDate>Thu, 12 May 2016 00:50:00 +0800</pubDate>
        <link>http://huangxuan.me/2016/05/12/lava-love/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/05/12/lava-love/</guid>
        
        <category>movie</category>
        
        <category>love story</category>
        
        
      </item>
    
      <item>
        <title>一道题分析动态规划</title>
        <description>&lt;p&gt;动态规划（Dynamic Programming）是面试算法常见考点。能够同时考察抽象总结以及归纳能力（需要计算递推公式，要知道递推在美国人眼里是很高级的技巧），以及coding的能力（动态规划一般要设计二维数组，以及复杂容易出错的index）。&lt;/p&gt;

&lt;p&gt;这篇博客，我试图通过求解Leetcode经典题目，&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/&quot;&gt;Best Time to Buy and Sell Stock IV&lt;/a&gt;, 来分析一下DP的总体思路。欢迎拍砖。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;一句话总结，动态规划是一个算法技巧，要解决大而复杂的问题，先解决小一点简单一点的问题，直到最简单的情况是可以直接得出结果，那么就能一步步反推出最终答案。&lt;/p&gt;

&lt;p&gt;听着和Conquer and Division很像，他们的差别是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;C&amp;amp;D一般是递归做法，DP一般是迭代做法&lt;/li&gt;
  &lt;li&gt;C&amp;amp;D一般对应二分，而DP一般对应递推。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;dp&quot;&gt;DP几大要素：&lt;/h2&gt;

&lt;p&gt;个人经验，认为DP有以下要素：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;识别DP&lt;/li&gt;
  &lt;li&gt;找递推关系&lt;/li&gt;
  &lt;li&gt;边界划分&lt;/li&gt;
  &lt;li&gt;初始化&lt;/li&gt;
  &lt;li&gt;例子验算&lt;/li&gt;
  &lt;li&gt;优化&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;dp-1&quot;&gt;识别DP&lt;/h4&gt;

&lt;p&gt;引自九章算法：&lt;/p&gt;

&lt;p&gt;如果题目目的是求最大值，最短距离，路径数量 etc. 而非求具体组合，具体点，每一条路径，那么很可能是DP。（求某一个组合，可能是DP+backtracking，求所有组合，则一般不是DP）&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;找递推关系&lt;/h4&gt;

&lt;p&gt;递推关系没有固定的套路，但简单地说有两种，一种是从头开始递推，一种是从尾部开始递推。思考的时候都要想到。&lt;/p&gt;

&lt;p&gt;从头开始递推例子：Best Time to Buy and Sell Stock &lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/&quot;&gt;1&lt;/a&gt;, &lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/&quot;&gt;3&lt;/a&gt;, &lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/&quot;&gt;4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从尾部开始递推例子: &lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/&quot;&gt;Best Time to Buy and Sell Stock with Cooldown&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;另一点是必须把递推关系写出来，可以从中找优化，并且可以帮助写code。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;边界划分&lt;/h4&gt;

&lt;p&gt;边界划分是分析，如果dp[k][i]表示第k层dp，位置从0到i范围，求取得到的最大值/最短距离 etc， 那么这个i表示的是什么。是一定要用到第i个数字吗，还是只需要是这个范围内的最大值。&lt;/p&gt;

&lt;p&gt;具体体验可以做 best stock &lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/&quot;&gt;4&lt;/a&gt;, 以及括号匹配数量(链接待补充)。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;初始化&lt;/h4&gt;

&lt;p&gt;顾名思义，最开始的值是多少。一般会有一行、一列辅助值，帮助初始化。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;例子验算(重要)&lt;/h4&gt;

&lt;p&gt;在实际写dp算法时，强烈建议先有一个演算好的例子，这样在写具体代码，尤其是index时，会清晰很多。另外DP常常需要保存中间变量，这个也在例子演算中标示出来会比较好。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;优化&lt;/h4&gt;

&lt;p&gt;这里优化指的是最后一步细节上的优化，总体时间复杂度已经无法再下降了。&lt;/p&gt;

&lt;p&gt;常见的优化有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;滚动数组，节省空间&lt;/li&gt;
  &lt;li&gt;剪枝，提早结束dp过程&lt;/li&gt;
  &lt;li&gt;特殊情况使用另一种更高效的算法&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;例子分析&lt;/h2&gt;

&lt;p&gt;如前所述，使用Leetcode经典题目，&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/&quot;&gt;Best Time to Buy and Sell Stock IV&lt;/a&gt;, 来分析一下DP的总体思路。&lt;/p&gt;

&lt;h4 id=&quot;dp-2&quot;&gt;识别DP&lt;/h4&gt;

&lt;p&gt;求最大price，符合DP条件。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;找递推关系 &amp;amp; 边界划分&lt;/h4&gt;

&lt;p&gt;递推关系的思考套路是，如果我已经知道1是怎么样，那么2是怎么样也知道，那么3是什么样也知道 etc&lt;/p&gt;

&lt;p&gt;在这里，转化成两个思考问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果我知道只有1笔transaction的结果，能否算出2笔transaction的结果？&lt;/li&gt;
  &lt;li&gt;如果我知道给定[0, i]范围交易结果，能否算出[0, i+1]的交易结果？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这道题如果研究清楚这两个递推关系，就算解决问题。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;1笔transaction推导2笔transaction&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;不难想到，如果我们知道[0, 1], [0,2], … , [0, i]的1笔transaction的交易结果，那么[0, i]的2笔transaction的交易结果，就是[0,1] - price[1]+price[i], …, [0, i-1] - price[i-1]+price[i]中的最大值。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[0, i]推导[0, i+1]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这个只要思考1笔transaction时是怎么样，其他情况类似。也不难想到，这个就是price[i+1] - min(price[0…i])和[0, i]中取较大值。&lt;/p&gt;

&lt;p&gt;关于边界划分，这里我当时犯了个错误，导致耽误了不少时间。就是[0, i]是表示必须以price[i]卖出呢，还是给定price[0, i]算出一个最大值，即[0, i]是一个单调递增序列。&lt;/p&gt;

&lt;p&gt;通过上面的结论我们已经得出，应该是第二种情况，但是实际思考时，都要想一下。&lt;/p&gt;

&lt;p&gt;另外值得一提，这道题要求是最多交易K笔，所以算出2笔transaction的结果，实际上表示是最多2笔transaction的结果，即如果1笔的结果更高，就保留1笔。&lt;/p&gt;

&lt;p&gt;最后推导递推公式。（实际上，这一步可以在例子验算之后进行）&lt;/p&gt;

&lt;p&gt;f(k)(i) = max(f(k)(i-1), max(f(k-1)(j)-price[j]+price[i]) where j=0…i-1)&lt;/p&gt;

&lt;p&gt;这里通过递推公式我们发现，每次计算f(k)(i) 一个0到i-1的j合集，这导致复杂度上升一个数量级。但是仔细观察，我们可以发现max(f(k-1)(j)-price[j]+price[i])中price[i]这一项是不变量，可以提取出来。即&lt;/p&gt;

&lt;p&gt;f(k)(i) = max(f(k)(i-1), price[i] + max(f(k-1)(j)-price[j]) where j=0…i-1)&lt;/p&gt;

&lt;p&gt;而max(f(k-1)(j)-price[j]) 这一项是可以在遍历时候维护的，因此每个f(k)(i)的计算复杂度为O(1)。&lt;/p&gt;

&lt;p&gt;总的时间复杂度为O(kN)&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;例子验算&lt;/h4&gt;

&lt;p&gt;例子验算对DP非常重要:&lt;br /&gt;
 - 验证正确性&lt;br /&gt;
 - 将coding过程直观化&lt;/p&gt;

&lt;p&gt;我们以&lt;a href=&quot;http://www.lintcode.com/zh-cn/problem/best-time-to-buy-and-sell-stock-iv/&quot;&gt;lintcode上的股票例子&lt;/a&gt;为例:&lt;/p&gt;

&lt;p&gt;[4,4,6,1,1,4,2,5] k = 2, ans = 6&lt;/p&gt;

&lt;p&gt;这是price list&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;[]()&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里每行k每列i是交易k次，并且给定[0, i]的price list，最多能成多少钱。&lt;/p&gt;

&lt;p&gt;另外根据上面的分析，我们需要一个变量（maxSub）来保存max(f(k-1)(j)-price[j])&lt;/p&gt;

&lt;p&gt;回顾递推公式：f(k)(i) = max(f(k)(i-1), price[i] + max(f(k-1)(j)-price[j]) where j=0…i-1)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;i=0&lt;/th&gt;
      &lt;th&gt;i=1&lt;/th&gt;
      &lt;th&gt;i=2&lt;/th&gt;
      &lt;th&gt;i=3&lt;/th&gt;
      &lt;th&gt;i=4&lt;/th&gt;
      &lt;th&gt;i=5&lt;/th&gt;
      &lt;th&gt;i=6&lt;/th&gt;
      &lt;th&gt;i=7&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0 maxSub = -4&lt;/td&gt;
      &lt;td&gt;0 maxSub = -4&lt;/td&gt;
      &lt;td&gt;2 maxSub = -4&lt;/td&gt;
      &lt;td&gt;2 maxSub = -1&lt;/td&gt;
      &lt;td&gt;2 maxSub = -1&lt;/td&gt;
      &lt;td&gt;3 maxSub = -1&lt;/td&gt;
      &lt;td&gt;3 maxSub = -1&lt;/td&gt;
      &lt;td&gt;4 maxSub = -1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0 maxSub = -4&lt;/td&gt;
      &lt;td&gt;0 maxSub = -4&lt;/td&gt;
      &lt;td&gt;2 maxSub = -4&lt;/td&gt;
      &lt;td&gt;2 maxSub = 1&lt;/td&gt;
      &lt;td&gt;2 maxSub = 1&lt;/td&gt;
      &lt;td&gt;5 maxSub = 1&lt;/td&gt;
      &lt;td&gt;5 maxSub = 1&lt;/td&gt;
      &lt;td&gt;6 maxSub = 1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;通过这个例子验算，我们在具体coding的时候，更容易写出bug free的代码。&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;初始化&lt;/h4&gt;

&lt;p&gt;这题有三个初始化，前两个是k为0的时候，以及i为0的时候 dp矩阵的值。不难理解都应该是0.&lt;/p&gt;

&lt;p&gt;另一个更重要的是maxSub的初始化，由于交易至少需要2个记录，因此i=0的时候可以算作买入的初始化。这样每次i从1开始遍历，而不是从0开始。&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;优化&lt;/h4&gt;

&lt;p&gt;本体可以有不少优化。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;滚动数组&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于每次只需要上一行的值，因此保留两行即可。（没有实现这个优化，建议可以用两个arraylist，每次结束后指针互换）&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;剪枝&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果发现dp[k][7] &amp;lt; dp[k-1][7],则可以结束。因为多了一笔交易不会变好，再多一笔也无济于事。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;特殊情况&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个是被leetcode逼的，不得不说leetcode的检测数据比lintcode不知道高到哪里去了。&lt;/p&gt;

&lt;p&gt;当K非常大，大到比price数量还多的时候，完全可以用&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/&quot;&gt;任意次交易算法&lt;/a&gt; 来O(N)时间完成。&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;写了这么多，也只是举了一个栗子，具体还要多多体会。&lt;/p&gt;

&lt;p&gt;总结DP思路：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;发现是DP（成功的开始）&lt;/li&gt;
  &lt;li&gt;初步寻找递推关系和边界条件。思考并写出递推关系式子。注意，这一步不要求最优，如果只是一些地方需要反复扫描，导致O(N)变成O(N^2)完全没问题。(进入DP大门)&lt;/li&gt;
  &lt;li&gt;演算，验证递推关系的正确性。&lt;/li&gt;
  &lt;li&gt;核心优化。如果第二步的推导不是最优，比如有明显的反复扫描，就要思考能不能把这个过程抹去，常见的是在扫描的过程中维护若干变量。(DP优化难点，面试的重点)&lt;/li&gt;
  &lt;li&gt;补充演算，验证优化的正确性。&lt;/li&gt;
  &lt;li&gt;coding&lt;/li&gt;
  &lt;li&gt;优化&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Fri, 29 Apr 2016 11:50:00 +0800</pubDate>
        <link>http://huangxuan.me/2016/04/29/dynamic-programming/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/04/29/dynamic-programming/</guid>
        
        <category>Algorithm</category>
        
        <category>Dynamic Programming</category>
        
        
      </item>
    
      <item>
        <title>异常处理：Panic/Exception 对比 Return Error</title>
        <description>&lt;p&gt;但凡编写实用的程序，都需要处理错误异常。常见的方法有两种，一种是抛出异常(throw Exception), 类似于Go语言中的panic, 另一种是返回一个错误标示, 类似于Go语言中返回error, 或是C语言中返回-1。&lt;/p&gt;

&lt;p&gt;常常有人讨论哪种做法更好。我认为以下观点值得参考。&lt;/p&gt;

&lt;p&gt;The rule is simple: if your function is in any way likely to fail, it should return an error. When I’m calling some other package, if it is well written I don’t have to worry about panics, except for, well, truly exceptional conditions, things I shouldn’t be expected to handle.&lt;/p&gt;

&lt;p&gt;Talk about error-code-style and exception-catch-style (Suggested by &lt;a href=&quot;https://plus.google.com/+RussCox-rsc/posts/iqAiKAwP6Ce&quot;&gt;Ross Cox&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20040422-00/?p=39683/&quot;&gt;Blog 1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20050114-00/?p=36693&quot;&gt;Blog 2&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 20 Apr 2016 16:17:00 +0800</pubDate>
        <link>http://huangxuan.me/2016/04/20/Panic-vs-Return-Error/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/04/20/Panic-vs-Return-Error/</guid>
        
        <category>Go</category>
        
        <category>Panic</category>
        
        
      </item>
    
      <item>
        <title>Concurrency vs. Parallelism</title>
        <description>&lt;p&gt;These notes are quoted from &lt;a href=&quot;https://www.youtube.com/watch?v=f6kdp27TYZs&quot;&gt;Go Concurrency Patterns&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;what-is-concurrency&quot;&gt;What is Concurrency&lt;/h3&gt;

&lt;p&gt;Programming as the composition of independently executing processes.&lt;/p&gt;

&lt;h3 id=&quot;what-is-parallelism&quot;&gt;What is Parallelism&lt;/h3&gt;

&lt;p&gt;Programming as the simultaneous execution of (possibly related) computations.&lt;/p&gt;

&lt;h3 id=&quot;concurrency-vs-parallelism&quot;&gt;Concurrency vs. Parallelism&lt;/h3&gt;

&lt;p&gt;Concurrency is about dealing with lots of things at once.&lt;/p&gt;

&lt;p&gt;Parallelism is about doing lots of things at once.&lt;/p&gt;

&lt;p&gt;One is about structure, one is about execution.&lt;/p&gt;

&lt;p&gt;Concurrency provides a way to structure a solution to solve a problem that may (but not necessarily) be parallelizable.&lt;/p&gt;

</description>
        <pubDate>Wed, 20 Apr 2016 13:22:00 +0800</pubDate>
        <link>http://huangxuan.me/2016/04/20/concurrency-vs-parallelism/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/04/20/concurrency-vs-parallelism/</guid>
        
        <category>Go</category>
        
        <category>Concurrency</category>
        
        <category>Parallelism</category>
        
        
      </item>
    
      <item>
        <title>A cheatsheet on basic of Go language</title>
        <description>&lt;h1 id=&quot;a-cheatsheet-on-basic-of-go-language&quot;&gt;A cheatsheet on basic of Go language&lt;/h1&gt;

&lt;p&gt;A collection of basic knowledge of Go language.&lt;/p&gt;

&lt;p&gt;Suitable for people who are both:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Familiar with (not necessary expert at) some other language, preferably C/C++.&lt;/li&gt;
  &lt;li&gt;Go though these three articles. &lt;a href=&quot;https://golang.org/doc/install&quot;&gt;Getting Started&lt;/a&gt;, &lt;a href=&quot;https://tour.golang.org/welcome/1&quot;&gt;A Tour of Go&lt;/a&gt;, &lt;a href=&quot;https://golang.org/doc/code.html&quot;&gt;How to Write Go Code&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;cheatsheet&quot;&gt;Cheatsheet&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;0.Entry point&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Go program starts from package main.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.Export&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Capitalized function is exported. Non-capitalized function isn’t exported.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.Variable type is at end of declaration.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var a int = 3
a int := 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.Basic types.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;bool, string
int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr
byte // alias for uint8
rune // alias for int32, represents a Unicode code point
float32 float64
complex64 complex128
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.Output type of a variable.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;printf(&quot;%T&quot;, variable)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;5.Type conversion/casting.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;new_type(variable)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6.const&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;const name = value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;7.Group of definition or import.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var/const (
  x = 1
  y = 2
)
import (
  &quot;package 1&quot;
  &quot;package 2&quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;8.Function with multiple return value.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func name(x int, y int) (int, int) {
  return 1, 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;9.Switch 1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Switch use &lt;code&gt;fallthrough&lt;/code&gt; as key word to let two consecutive cases run sequentially. In Go, we don’t use &lt;code&gt;break&lt;/code&gt; key word to terminate switch cases, they stop automatically.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10.Switch 2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Value of switch case could be any type, even function value is okay. Using switch without a condition is okay, then the switch case takes some boolean value, this is useful for concise if-else combination.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11.Defer&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The deferred call’s arguments are evaluated immediately, but the function call is not executed until the surrounding function returns. When there are multiple defer functions, they are stacked in a FILO pattern.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;12.Pointer&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Pointer is like c-style, but do not support pointer arithmetic.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;13.Struct&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type Name struct {
  x int
  y int
}
name := Name{x:1, y:2}
name.x
p = &amp;amp;name
p.x is okay!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;14.Array&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var name [10]int
name := [3]int{1,2,3}
name := […]int{1,2,3} //same effect as previous statement
len(name)
cap(name) //capacity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;15.Slice&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Slice is similar to array, but more flexible! Array is fixed sized, while size of slice could be modified. It is built on top of array, which is very similar to list in Java.&lt;/p&gt;

&lt;p&gt;Internal of slice is a pointer to a position in an array, the length, the capacity.&lt;/p&gt;

&lt;p&gt;Slice could be create by make&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;name := make([]int, length)
name := make([]int, length, capacity)
name := make([]int, 0, 5) //an array with capacity 5 and length 0, initialized all value 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or by slicing an array or slice&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;name[1:3] //have value at position 1,2. name could be an array or slice
name[1:]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When creating slice by slicing, the data is not copied! just modify the pointer&lt;/p&gt;

&lt;p&gt;And notice, when slicing, the length is determined by slice range, but the capacity is determined by maximum range which is from slice range begin to end of underlying array.&lt;/p&gt;

&lt;p&gt;Notice, this may cause problem because we may only need part of the array, but we are keeping the whole array in memory. So sometimes it would be better to copy that part, or other method such as append part of array to a &lt;code&gt;nil&lt;/code&gt; array, to let garbage collector reclaim those memory.&lt;/p&gt;

&lt;p&gt;https://blog.golang.org/go-slices-usage-and-internals&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;16.Slice is initialized as nil&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var name []int
name == nil //true
len(name) //0
cap(name) //0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;17.Slice copy/append&lt;/strong&gt;&lt;br /&gt;
Slice could be copied between different lengthy,  or even underlying overlapped slices.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;copy(destination, source)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;this will copy elements of smaller number in &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var name = []int{1,2,3}
append(name, 1, 2, 3)

var name2= []int{4,5,6}
append(name, name2…) //could append another slice. notice the … would unwrap the second slice
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;18.Array/slice range&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A convenient way to iterate element in array and slice.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;for index, value := range arrayName {
  //notice value is a copy of the element
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Could skip the value, then&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;for index := range arrayName {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or could skip index, then&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;for _, v := range array {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;19.Map&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Map must be created using make.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var name = make(map[key_type] value_type)
var map = make(map[string] int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or could be initialized like JSON.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var map = make(map[string] int) {
  &quot;key1&quot;:10,
  &quot;key2&quot;:20, //notice the commas is necessary!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Map operation is usual.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;map[key] = value
value, ok = map[key] //ok is true if key exist
delete(map, key)

for key, value := map {
  //iterate map
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;20.Function as first class&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Could pass function as a parameter.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func name(fn func(x, y int) int) int {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice all function argument is value copy. Not reference.&lt;/p&gt;

&lt;p&gt;Also, function has closure.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;21.Class&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Go doesn’t have built-in class. But we could use function to help variable to act like a class.&lt;/p&gt;

&lt;p&gt;We should assign a &lt;em&gt;receiver&lt;/em&gt; type to a function, then any variable of this receiver type could call this function. So it looks like the receiver type is a class, variable is an object, and the function is a member function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var (f MyFloat) Abs() float64 {}//MyFloat is receiver type
var Abs(f MyFloat) float64{} //function-wise same
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But receiver could only be type defined in the same package. So could not set receiver as built-in type, including &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; etc.&lt;/p&gt;

&lt;p&gt;Receiver could be pointer. This does not require the variable calling this function to be a pointer. It means the value of receiver is not copied to the function, instead a reference is given so that the function could modify the value of receiver. Though use a pointer as receiver variable to call function is recommended!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var (f *MyFloat) Abs() {} //now Abs could directly modify f in its body
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All methods on a given type should have either value or pointer receivers, but not a mixture of both. (This is a design matter)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;22.Interface&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type name interface {
  functionName(argument) return_type
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;name x&lt;/code&gt; could be any type that support the function.&lt;/p&gt;

&lt;p&gt;Empty interface acts like &lt;code&gt;void*&lt;/code&gt; in C language.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var i interface{} //empty interface, i is nil after created
i = “aa&quot;
i = 43 //both are correct
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because the interface could be assigned to any concrete variable, sometimes we want to know what’s underlying concrete type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var i interface{} = &quot;hello&quot;
s := i.string //s will be “hello&quot;
f := i.float64 //run time error
f, ok := i.float64 //no error, ok would be false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;23.Switch 3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Switch could be used to switch types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;switch v:= i.(type) {
case T:
case S:
default:
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;24.Stringer interface&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A built-in interface, similar to &lt;code&gt;toString()&lt;/code&gt; in Java.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type Stringer interface {
  String() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;25.Error&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Every built-in function return an error as last parameter.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;return_value, err = function_name()
if err == nil {} else {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;26.IO Reader&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Reader is an input stream.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;import {
  &quot;io&quot;
  &quot;strings&quot;
}
r := strings.NewReader(&quot;Hello, Reader!&quot;)
b := make([]byte, 8)
n, err := r.Read(b)
if err == io.EOF {
  break
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;27. Routine&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Routine is like thread in other languages. You run a function in another thread.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;go fun_name(parameters)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This starts a new goroutine/ light-weight thread. The parameters are evaluated when executing this line, i.e. current goroutine, but execution of the function is happen in the new goroutine, i.e. in the future.&lt;/p&gt;

&lt;p&gt;These go routines run in same address space, so that access to shared memory need synchronized.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;28.Rendezvous channel&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Rendezvous means synchronized. A rendezvous channel is a channel without defining size, so that the sender and receiver would be synchronized all the time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var channel = make(chan int)
channel &amp;lt;- v  //offer v into channel, block until v is taken from receiver
v := &amp;lt;- channel //take v from channel, block until sender offer a value into channel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;29.Buffered channel&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Buffered channel is channel with a defined capacity. So the sender and receiver could act like producer consumer model, where the channel acts like a queue with fixed size.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;var channel = make(chan int, capacity)
channel &amp;lt;- v //sender be blocked when channel full
v := &amp;lt;- channel //receiver blocked when channel empty
cap(channel) //capacity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;30.Channel close and check&lt;/strong&gt;&lt;br /&gt;
Sender &lt;em&gt;could&lt;/em&gt;  and only sender &lt;em&gt;should&lt;/em&gt; close channel&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;close(channel)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Receiver could check whether channel is closed by&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;v, ok := &amp;lt;- channel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A channel could be iterated using range.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;for i:= range(channel) {
  //i is element in channel
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;when channel is closed, this iteration will stop.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;31.Select&lt;/strong&gt;&lt;br /&gt;
Select a random executable statement to run. Notice each case statement should interact with a channel.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;select {
  case c &amp;lt;- x://executable when channel is not full
  case &amp;lt;- c: //executable when channel is not empty
  default ://executable when channel is neither full nor empty
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;32.sync.Mutex&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Go provide built-in mutex acting as lock. Though it suggests design pattern to do concurrency without locks.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;mux sync.Mutex
mux.Lock()
//do something
mux.Unlock()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;33.Share memory by communicating&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Don’t communicate by sharing memory; share memory by communicating.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://golang.org/doc/codewalk/sharemem/&quot;&gt;Go blog: shareemem codewalk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A naive interpretation: Do not use lock and shared memory, as a method to communicate among threads. Instead, use channel as communication tool, and share data among threads without lock.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;34.Go syntax&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A good post talking about why’s the similarity and difference between Go syntax and C syntax.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.golang.org/gos-declaration-syntax&quot;&gt;Go blog: Go’s declaration syntax&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;35.Defer, panic, recover&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A defer statement pushes a function call onto a list. The list of saved calls is executed after the surrounding function returns. Defer is commonly used to simplify functions that perform various clean-up actions.&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;A deferred function’s arguments are evaluated when the defer statement is evaluated.&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;Deferred function calls are executed in Last In First Out order after the surrounding function returns.&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;Deferred functions may read and assign to the returning function’s named return values.&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;This is convenient for modifying the error return value of a function&lt;/p&gt;

  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

  &lt;p&gt;Panic is a built-in function that stops the ordinary flow of control and begins panicking. When the function F calls panic, execution of F stops, any deferred functions in F are executed normally, and then F returns to its caller. To the caller, F then behaves like a call to panic. The process continues up the stack until all functions in the current goroutine have returned, at which point the program crashes. Panics can be initiated by invoking panic directly. They can also be caused by runtime errors, such as out-of-bounds array accesses.&lt;/p&gt;

  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

  &lt;p&gt;Recover is a built-in function that regains control of a panicking goroutine. Recover is only useful inside deferred functions. During normal execution, a call to recover will return nil and have no other effect. If the current goroutine is panicking, a call to recover will capture the value given to panic and resume normal execution.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.golang.org/defer-panic-and-recover&quot;&gt;Go blog: defer panic and recover&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;36.Test&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Go provides a built-in test platform.&lt;/p&gt;

&lt;p&gt;The convention is:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Within the package, have a go file named XXX__test.go&lt;/li&gt;
  &lt;li&gt;Within this go file, have functions named TestXXX.go&lt;/li&gt;
  &lt;li&gt;The test function should have format as&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;go
  func TestXXX(t *testing.T) {}
 &lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Import package &lt;code&gt;&quot;testing&quot;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Use &lt;a href=&quot;https://golang.org/pkg/testing/&quot;&gt;test functions&lt;/a&gt; to indicate error. This including&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;t.Error
t.Errorf
t.Fail
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 23 Mar 2016 16:09:00 +0800</pubDate>
        <link>http://huangxuan.me/2016/03/23/cheatsheet-go-basics/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/03/23/cheatsheet-go-basics/</guid>
        
        <category>Go</category>
        
        
      </item>
    
      <item>
        <title>Cracking Code Challenge The Hard Way - Stack, Queue, Priority Queue and advanced applications (1) -- Stack and Monotone Priority Queue</title>
        <description>&lt;h1 id=&quot;cracking-code-challenge-the-hard-way---stack-queue-priority-queue-and-advanced-applications-1----stack-and-monotone-priority-queue&quot;&gt;Cracking Code Challenge The Hard Way - Stack, Queue, Priority Queue and advanced applications (1) – Stack and Monotone Priority Queue&lt;/h1&gt;

&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;Awww yah!&lt;/p&gt;

&lt;p&gt;In these short series, I will cover basic data structures including Stack, Queue, and Priority Queue, and there mutations or advanced applications, including Priority Queue with log time complexity deletion, Monotone Priority Queue and Deque.&lt;/p&gt;

&lt;p&gt;This article will cover Stack and Monotone Priority Queue.&lt;/p&gt;

&lt;p&gt;These problems will be included in this article:&lt;/p&gt;

&lt;p&gt;Stack&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&quot;https://leetcode.com/problems/binary-tree-preorder-traversal/&quot;&gt;Binary Tree Preorder Traversal&lt;/a&gt;&lt;br /&gt;
 2.&lt;a href=&quot;https://leetcode.com/problems/binary-tree-inorder-traversal/&quot;&gt;Binary Tree Inorder Traversal&lt;/a&gt;&lt;br /&gt;
 3.&lt;a href=&quot;https://leetcode.com/problems/binary-tree-postorder-traversal/&quot;&gt;Binary Tree Postorder Traversal&lt;/a&gt;&lt;br /&gt;
 4.&lt;a href=&quot;https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/&quot;&gt;Verify Preorder Sequence in Binary Search Tree&lt;/a&gt;&lt;br /&gt;
 5.&lt;a href=&quot;https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/&quot;&gt;Verify Preorder Serialization of a Binary Tree&lt;/a&gt;&lt;br /&gt;
 6.&lt;a href=&quot;https://leetcode.com/problems/evaluate-reverse-polish-notation/&quot;&gt;Evaluate Reverse Polish Notation&lt;/a&gt;&lt;br /&gt;
 7.&lt;a href=&quot;https://leetcode.com/problems/basic-calculator/&quot;&gt;Basic Calculator&lt;/a&gt;&lt;br /&gt;
 8.&lt;a href=&quot;https://leetcode.com/problems/basic-calculator-ii/&quot;&gt;Basic Calculator II&lt;/a&gt;&lt;br /&gt;
  9.&lt;a href=&quot;https://leetcode.com/problems/valid-parentheses/&quot;&gt;Valid Parentheses&lt;/a&gt;&lt;br /&gt;
  10.&lt;a href=&quot;https://leetcode.com/problems/longest-valid-parentheses/&quot;&gt;Longest Valid Parentheses&lt;/a&gt;&lt;br /&gt;
  11.&lt;a href=&quot;https://leetcode.com/problems/remove-invalid-parentheses/&quot;&gt;Remove Invalid Parentheses&lt;/a&gt;&lt;br /&gt;
   12.&lt;a href=&quot;https://leetcode.com/problems/largest-rectangle-in-histogram/&quot;&gt;Largest Rectangle in Histogram&lt;/a&gt;&lt;br /&gt;
 13.&lt;a href=&quot;http://www.lintcode.com/en/problem/max-tree/#&quot;&gt;Max Tree&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;stack&quot;&gt;Stack&lt;/h2&gt;

&lt;h3 id=&quot;key-idea&quot;&gt;Key Idea&lt;/h3&gt;

&lt;p&gt;Stack is helpful when the problem could be solved in a format that every new incoming data/element, referencing formerly saved data/elements &lt;strong&gt;sequentially and backwardly&lt;/strong&gt;, could produce something that is either useful for the next round iteration/recursion, or part of the answer.&lt;/p&gt;

&lt;p&gt;In other words, Stack is used when:&lt;/p&gt;

&lt;p&gt;Result is computed when data is coming sequentially. Also, if a part of result given by incoming data is dependent on formerly saved data, these formerly saved data could only be used sequentially, in a reverse order when they are pushed into the stack.&lt;/p&gt;

&lt;p&gt;No worry if you don’t fully understand this sentence know. Keep it in mind and let’s crack some coding problem!&lt;/p&gt;

&lt;h3 id=&quot;complexity-analysis&quot;&gt;Complexity Analysis&lt;/h3&gt;

&lt;p&gt;Generally speaking, an algorithm designed using stack has $O(N)$ time and space complexity.&lt;/p&gt;

&lt;p&gt;The three most frequently used operation on stack – push, pop and peek use $O(1)$/constant extra space and $O(1)$/constant time. More specifically, the push operation uses amortized $O(1)$ time if stack is implemented using array, since we have to extend array from time to time.&lt;/p&gt;

&lt;h3 id=&quot;tree-traversal-basic-level&quot;&gt;Tree traversal (basic level)&lt;/h3&gt;

&lt;p&gt;Lots of problems related to tree traversal operation could be optimized using stack. By “optimized” I mean you could solve these problems without manage the stack yourselves, i.e. using system stack.&lt;/p&gt;

&lt;p&gt;But manage stack by yourselves has at least two advantages.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Self-managed stack is created in heap space, so that we are far less worried about if there is enough space. This is because stack is generally way smaller than heap (all system/process structure level).&lt;/li&gt;
  &lt;li&gt;When popping multiple elements from stack, it is more straightforward to do this in a while/for loop, instead of recursively going back.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Solve these problems in both recursive(stack managed by operation system) and iterative(stack managed by programmer) ways. Feel the simplicity of recursion method and manage basic skills using stack.&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&quot;https://leetcode.com/problems/binary-tree-preorder-traversal/&quot;&gt;Binary Tree Preorder Traversal&lt;/a&gt;&lt;br /&gt;
 2.&lt;a href=&quot;https://leetcode.com/problems/binary-tree-inorder-traversal/&quot;&gt;Binary Tree Inorder Traversal&lt;/a&gt;&lt;br /&gt;
 3.&lt;a href=&quot;https://leetcode.com/problems/binary-tree-postorder-traversal/&quot;&gt;Binary Tree Postorder Traversal&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Be more familiar with stack and order in tree.&lt;/p&gt;

&lt;p&gt;4.&lt;a href=&quot;https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/&quot;&gt;Verify Preorder Sequence in Binary Search Tree&lt;/a&gt;&lt;br /&gt;
 5.&lt;a href=&quot;https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/&quot;&gt;Verify Preorder Serialization of a Binary Tree&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;indirect-tree-traversal-medium-level&quot;&gt;Indirect tree traversal (medium level)&lt;/h3&gt;

&lt;p&gt;Calculation tree problem is a good practice and application on top of tree traversal operation. They give you an insight of how a string-like expression could be conceptually translated to a tree, and solved using tree traversal.&lt;/p&gt;

&lt;p&gt;Jump to the second and third problem if you want to challenge yourself, otherwise check the first problem and &lt;a href=&quot;https://en.wikipedia.org/wiki/Reverse_Polish_notation&quot;&gt;Reverse Polish notation&lt;/a&gt; first.&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&quot;https://leetcode.com/problems/evaluate-reverse-polish-notation/&quot;&gt;Evaluate Reverse Polish Notation&lt;/a&gt;&lt;br /&gt;
 2.&lt;a href=&quot;https://leetcode.com/problems/basic-calculator/&quot;&gt;Basic Calculator&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;After solving the calculation tree problems, you should have idea to solve parenthesis problems. They partly share the same idea.&lt;/p&gt;

&lt;p&gt;4.&lt;a href=&quot;https://leetcode.com/problems/valid-parentheses/&quot;&gt;Valid Parentheses&lt;/a&gt;&lt;br /&gt;
  5.&lt;a href=&quot;https://leetcode.com/problems/longest-valid-parentheses/&quot;&gt;Longest Valid Parentheses&lt;/a&gt;&lt;br /&gt;
  6.&lt;a href=&quot;https://leetcode.com/problems/remove-invalid-parentheses/&quot;&gt;Remove Invalid Parentheses&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;stack-as-monotone-priority-queue-advanced-level&quot;&gt;Stack as Monotone Priority Queue (advanced level)&lt;/h3&gt;

&lt;p&gt;Even though I put these problems in advanced level category, you may find them easy once you get the idea.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[Hint (don’t read the following part unless you get stuck):]&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The key idea for these two problems are the same: each new incoming data could help to calculate the final answer, combined with formerly saved data, but only part of them! Which part? Either the data that is larger than itself, or is smaller than itself.&lt;/p&gt;

&lt;p&gt;In this way, we could maintain the stack in a way that all data belong to this stack is monotonically increasing or decreasing. This idea is also called Monotone Priority Queue.&lt;/p&gt;

&lt;p&gt;For more detailed hints and thoughts, see my answer to these problems.&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&quot;https://leetcode.com/problems/largest-rectangle-in-histogram/&quot;&gt;Largest Rectangle in Histogram&lt;/a&gt;&lt;br /&gt;
 2.&lt;a href=&quot;http://www.lintcode.com/en/problem/max-tree/#&quot;&gt;Max Tree&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Mar 2016 20:18:00 +0800</pubDate>
        <link>http://huangxuan.me/2016/03/14/Cracking-Code-Challenge-The-Hard-Way-Stack-Queue-Priority-Queue-and-advanced-applications-1-Stack-and-Monotone-Priority-Queue/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/03/14/Cracking-Code-Challenge-The-Hard-Way-Stack-Queue-Priority-Queue-and-advanced-applications-1-Stack-and-Monotone-Priority-Queue/</guid>
        
        <category>code challenge</category>
        
        <category>stack</category>
        
        <category>monotone priority queue</category>
        
        
      </item>
    
      <item>
        <title>Cracking Code Challenge The Hard Way - Iterator Design Pattern</title>
        <description>&lt;h1 id=&quot;design-problem---iterator&quot;&gt;Design Problem - Iterator&lt;/h1&gt;

&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;This article talks about how to design a generic iterator that supports &lt;code&gt;next()&lt;/code&gt;, &lt;code&gt;hasNext()&lt;/code&gt; and &lt;code&gt;getCurrent()&lt;/code&gt; methods.&lt;/p&gt;

&lt;h2 id=&quot;why-use-iterator&quot;&gt;Why use iterator?&lt;/h2&gt;

&lt;p&gt;To traverse a data structure, one could either use index to go through it, or could use an iterator. An iterator basically has several advantages over index traverse:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Most important, at least to me, is that given a streaming data, which means we don’t know size of input, then we could not use index to go through since we don’t know when to stop.&lt;/li&gt;
  &lt;li&gt;Even we could know the size beforehand, it could be difficult/expensive to calculate this. For example, calculation of size of a LinkedList could be O(N), through not the case in Java.&lt;/li&gt;
  &lt;li&gt;There are quite a few important data structures that doesn’t support random access, including Set, LinkedList, Tree etc.&lt;/li&gt;
  &lt;li&gt;Iterator provides a high level concept of traversing, using the general function &lt;code&gt;hasNext()&lt;/code&gt;, &lt;code&gt;next()&lt;/code&gt; etc. so that we could iterate despite underlying data structure. See more about &lt;a href=&quot;https://en.wikipedia.org/wiki/Generic_programming&quot;&gt;generic programming&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Iterator is fail-fast (at least in Java), which means it could help to prevent some concurrent modification conflict. On the other side, index traverse doesn’t provide such protection.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;what-is-iterator&quot;&gt;What is Iterator&lt;/h2&gt;

&lt;p&gt;The core idea of iterator is that it knows&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;the current position in a data structure&lt;/li&gt;
  &lt;li&gt;how to go to the next position&lt;/li&gt;
  &lt;li&gt;if it is the end of data structure&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;By abstracting these three most important functions, an iterator has to implement three corresponding methods:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;getCurrent()&lt;/code&gt; return current value pointed by iterator&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;next()&lt;/code&gt; go to next position. If such position doesn’t exist, throw an exception.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;hasNext()&lt;/code&gt; check if it is the end, this function should be called each time before we call &lt;code&gt;next()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Given these information, we have our iterator interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface Iterator&amp;lt;T&amp;gt; {
	public T getCurrent() throws NoSuchElementException;
	public T next() throws NoSuchElementException;
	public boolean hasNext();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fairly easy, right? Indeed it is! Now let’s see how to design a concrete iterator.&lt;/p&gt;

&lt;h2 id=&quot;iterator-of-arraylist&quot;&gt;Iterator of ArrayList&lt;/h2&gt;

&lt;p&gt;In Java, get size of ArrayList is constant time, so we could use size as boundary to check if we hit end of list.&lt;/p&gt;

&lt;p&gt;First, we need some private field to help manage iteration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//Size of underlying data structure
private int size;
//Used to iterate through data structure, it always points to next element
//to be iterated
private int cursor;
//Point to current value, initially -1
private int current;
//Used to save underlying data structure
private Object[] elementData;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, check if we hit end of list is simple, just check if cursor is at end of list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/*
 * Check if we hit end of data structure.
 */
public boolean hasNext() {
    return cursor != size;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to get next value, we first check &lt;code&gt;hasNext()&lt;/code&gt;, if true then we go on return the value pointed by cursor, otherwise we throw exception.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/*
 * Get next value of iterator, move iterator to next position at the
 * same time. If already at end of data structure, throw exception.
 */
@SuppressWarnings(&quot;unchecked&quot;)
public T next() throws NoSuchElementException {
    if(!hasNext()) {
        throw new NoSuchElementException();
    }
    current = cursor++;
    return (T)elementData[current];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, to get current value is very straightforward.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/*
 * Get current value pointed by iterator
 */
@SuppressWarnings(&quot;unchecked&quot;)
public T getCurrent() throws NoSuchElementException {
    if(current &amp;lt; 0) {
        throw new NoSuchElementException();
    }
    return (T)elementData[current];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could get full source code at &lt;a href=&quot;https://github.com/otnt/CodeChallenge/tree/master/DesignPattern/iterator/src/iterator&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;java-open-jdk-implementation&quot;&gt;Java Open-JDK Implementation&lt;/h2&gt;

&lt;p&gt;To learn more about iterator in Java, I highly suggest you read some Java source code. They are extremely easy to follow.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/util/Iterator.java&quot;&gt;Iterator interface&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/util/ArrayList.java#ArrayList.Itr&quot;&gt;ArrayList Iterator&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/util/ListIterator.java#ListIterator&quot;&gt;ListIterator interface&lt;/a&gt; (An iterator supports both moving forward and backward)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/util/ArrayList.java#ArrayList.ListItr&quot;&gt;ArrayList ListIterator&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/util/HashMap.java#HashMap.HashIterator&quot;&gt;Hash Iterator&lt;/a&gt; (Iterator implementation in HashMap is a little bit different since the underlying data structure is different. But the general idea is the same)&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sat, 05 Mar 2016 01:01:00 +0800</pubDate>
        <link>http://huangxuan.me/2016/03/05/Cracking-Code-Challenge-The-Hard-Way-Iterator-Design-Pattern/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/03/05/Cracking-Code-Challenge-The-Hard-Way-Iterator-Design-Pattern/</guid>
        
        <category>design pattern</category>
        
        <category>iterator</category>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>Why Go Abroad</title>
        <description>&lt;h1 id=&quot;why-go-abroad&quot;&gt;Why Go Abroad?&lt;/h1&gt;

&lt;h2 id=&quot;why-this-question&quot;&gt;Why this question?&lt;/h2&gt;

&lt;p&gt;最近和浩宇——一位很要好的学弟——聊天，问我对出国与否的看法。突然间我很好奇SV的伙伴们都有何独特见解。所以在这里搜罗了一些CMUSV朋友的观点。对之后考虑出国的年轻人可能有些许借鉴之用，而我们这些兄弟/姐妹日后回顾起来一定也别有风味。&lt;/p&gt;

&lt;h2 id=&quot;why-you-decided-go-abroad&quot;&gt;Why you decided go abroad?&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;浦饭的回答：&lt;/em&gt;&lt;br /&gt;
我最初决定出国的原因很LOW。一是我想转做software，而我本科学的是communication/signal方向，几乎没有CS背景，并且实习经历为零，所以读master是看起来最快最有效的转行方法。二是我从小学到大学全是在上海，一直在父母的关照之下让我有些无所适从，让我在偶尔必须迈出恐惧的步伐时选择了退缩，所以我要离开父母。&lt;/p&gt;

&lt;h2 id=&quot;why-suggest-going-abroad&quot;&gt;Why suggest going abroad?&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;浦饭的回答：&lt;/em&gt;&lt;br /&gt;
1.优质的教学+Inspiring的环境。作为体会过CMU两个校区的人我有不少感触。SV这边地处Bay Area，在周遭走一圈就觉得浑身亢奋，想着当年Google在一个小办公室中实现日后所向披靡的互联网入口，想着Zack在这里实现每天约谈一个陌生人的计划，想着无数公司和智慧的火花在这里兴起与衰落，感觉肾上腺素爆棚。另一方面，CMU Pitts本部的课程质量相信绝不逊于Stanford、MIT、Berkeley这三所顶级学府；这里有云平台、分布式系统、计算机系统、大数据处理、机器学习、计算机安全等各行的顶级大牛，并且乐意分享与解答学生问题，有太多知识的盛宴。&lt;/p&gt;

&lt;p&gt;2.多样化/Diversity。和印度同学交流，我才知道绝大部分印度人都有自己的宗教信仰，而印度语言繁杂，几乎每个人都会至少2-3个不同语言，印度人素食主义者非常多，而他们确实坚信阅兵式上叠罗汉式的表演非常有创意。和台湾同学交流，可以和他们抱怨中国护照的不方便之处，抱怨中国传统文化的断层，也可以肆无忌惮“嘲笑”台湾经济的衰退。和黎巴嫩同学交流，才知道原来他们也搞不清中东到底在玩什么XD&lt;/p&gt;

&lt;p&gt;3.创客精神。这点国内未必会差，但起码Bay Area的创客精神很浓。湾区作为engineer的小天堂，所以开源精神收到追捧，有那么多人希望用创新的手段改善人们的生活，有那么多让人拍案叫绝的想法，而不是仅仅把工作当做挣钱的手段。&lt;/p&gt;

&lt;h2 id=&quot;why-suggest-not-going-abroad&quot;&gt;Why suggest NOT going abroad?&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;浦饭的回答：&lt;/em&gt;&lt;br /&gt;
1.交流/文化的障碍。这是不少人绕不开的一个话题，我也在struggle中。&lt;/p&gt;

&lt;p&gt;2.无依无靠。身在国外，可以利用的现成资源肯定是减少了，大部分资源要靠自己去争取。&lt;/p&gt;

&lt;p&gt;3.Losting。尽管之前说了湾区那么多好话，但有时静下心来想，会觉得湾区的创客精神也有点类似于AIESEC这类组织的“鸡血式培训”，它让你work hard, play harder，让你获得成就感，让你用自己的能力改变世界，让你逃避一些内心不敢思考的东西。。。有时候我问自己，如果明天突然获得两天假期，不准干任何技术相关内容，我是否会有些许无所适从。而这种不安感，我觉得是lost内心的体现。&lt;/p&gt;

&lt;h2 id=&quot;anything-else-you-wanna-say-dream-life-disappointments&quot;&gt;Anything else you wanna say? Dream… Life… Disappointments…&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;浦饭的回答：&lt;/em&gt;&lt;br /&gt;
最近觉得奋斗也是一种毒品——付出、收获的循环也不过是短暂的快感，而后只能靠更大的付出与更大的收获来维持这多巴胺的分泌，这和毒品简直如出一辙。之前所说的losting，就像是毒瘾发作，如果长期得不到“收获”这包白粉，就会抓狂、心绪混乱。&lt;/p&gt;

&lt;p&gt;而这也是我坚持反对盲目奋斗、盲目努力的原因，没有一个很好的释放途径、一个阶梯式成长的路线，就像一次倾家荡产买了大批毒品吸食，而后续无法持续补给，最终很可能是毒发而亡。&lt;/p&gt;

&lt;p&gt;从男人角度思考，我觉得事业上一定要有dream，才不会鼠目寸光，不会束手束脚；而家庭上要尽早落地，才能避免盲目的拼搏挣断了现实的风筝线。&lt;/p&gt;
</description>
        <pubDate>Fri, 26 Feb 2016 02:17:00 +0800</pubDate>
        <link>http://huangxuan.me/2016/02/26/why-go-abroad/</link>
        <guid isPermaLink="true">http://huangxuan.me/2016/02/26/why-go-abroad/</guid>
        
        <category>personal</category>
        
        <category>thought</category>
        
        <category>life</category>
        
        
      </item>
    
  </channel>
</rss>
